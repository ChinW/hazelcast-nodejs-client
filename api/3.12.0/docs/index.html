<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>hazelcast-client</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">hazelcast-client</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> hazelcast-client</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><a href="https://gitter.im/hazelcast-incubator/hazelcast-nodejs-client?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/hazelcast-incubator/hazelcast-nodejs-client"></a></p>
				<h1 id="table-of-contents">Table of Contents</h1>
				<ul>
					<li><a href="#introduction">Introduction</a></li>
					<li><a href="#1-getting-started">1. Getting Started</a><ul>
							<li><a href="#11-requirements">1.1. Requirements</a></li>
							<li><a href="#12-working-with-hazelcast-imdg-clusters">1.2. Working with Hazelcast IMDG Clusters</a><ul>
									<li><a href="#121-setting-up-a-hazelcast-imdg-cluster">1.2.1. Setting Up a Hazelcast IMDG Cluster</a><ul>
											<li><a href="#1211-running-standalone-jars">1.2.1.1. Running Standalone JARs</a></li>
											<li><a href="#1212-adding-user-library-to-classpath">1.2.1.2. Adding User Library to CLASSPATH</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#13-downloading-and-installing">1.3. Downloading and Installing</a></li>
							<li><a href="#14-basic-configuration">1.4. Basic Configuration</a><ul>
									<li><a href="#141-configuring-hazelcast-imdg">1.4.1. Configuring Hazelcast IMDG</a></li>
									<li><a href="#142-configuring-hazelcast-nodejs-client">1.4.2. Configuring Hazelcast Node.js Client</a><ul>
											<li><a href="#1421-group-settings">1.4.2.1. Group Settings</a></li>
											<li><a href="#1422-network-settings">1.4.2.2. Network Settings</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#15-basic-usage">1.5. Basic Usage</a></li>
							<li><a href="#16-code-samples">1.6. Code Samples</a></li>
						</ul>
					</li>
					<li><a href="#2-features">2. Features</a></li>
					<li><a href="#3-configuration-overview">3. Configuration Overview</a><ul>
							<li><a href="#31-configuration-options">3.1. Configuration Options</a><ul>
									<li><a href="#311-programmatic-configuration">3.1.1. Programmatic Configuration</a></li>
									<li><a href="#312-declarative-configuration-json">3.1.2. Declarative Configuration (JSON)</a></li>
								</ul>
							</li>
							<li><a href="#32-importing-multiple-configurations">3.2. Importing Multiple Configurations</a></li>
							<li><a href="#33-loading-objects-and-path-resolution">3.3. Loading Objects and Path Resolution</a></li>
						</ul>
					</li>
					<li><a href="#4-serialization">4. Serialization</a><ul>
							<li><a href="#41-identifieddataserializable-serialization">4.1. IdentifiedDataSerializable Serialization</a></li>
							<li><a href="#42-portable-serialization">4.2. Portable Serialization</a></li>
							<li><a href="#43-custom-serialization">4.3. Custom Serialization</a></li>
							<li><a href="#44-global-serialization">4.4. Global Serialization</a></li>
							<li><a href="#45-json-serialization">4.5. JSON Serialization</a></li>
							<li><a href="#46-string-serialization">4.6. String Serialization</a></li>
						</ul>
					</li>
					<li><a href="#5-setting-up-client-network">5. Setting Up Client Network</a><ul>
							<li><a href="#51-providing-member-addresses">5.1. Providing Member Addresses</a></li>
							<li><a href="#52-setting-smart-routing">5.2. Setting Smart Routing</a></li>
							<li><a href="#53-enabling-redo-operation">5.3. Enabling Redo Operation</a></li>
							<li><a href="#54-setting-connection-timeout">5.4. Setting Connection Timeout</a></li>
							<li><a href="#55-setting-connection-attempt-limit">5.5. Setting Connection Attempt Limit</a></li>
							<li><a href="#56-setting-connection-attempt-period">5.6. Setting Connection Attempt Period</a></li>
							<li><a href="#57-enabling-client-tlsssl">5.7. Enabling Client TLS/SSL</a></li>
							<li><a href="#58-enabling-hazelcast-cloud-discovery">5.8. Enabling Hazelcast Cloud Discovery</a></li>
						</ul>
					</li>
					<li><a href="#6-securing-client-connection">6. Securing Client Connection</a><ul>
							<li><a href="#61-tlsssl">6.1. TLS/SSL</a><ul>
									<li><a href="#611-tlsssl-for-hazelcast-members">6.1.1. TLS/SSL for Hazelcast Members</a></li>
									<li><a href="#612-tlsssl-for-hazelcast-nodejs-clients">6.1.2. TLS/SSL for Hazelcast Node.js Clients</a></li>
									<li><a href="#613-mutual-authentication">6.1.3. Mutual Authentication</a></li>
								</ul>
							</li>
							<li><a href="#62-credentials">6.2. Credentials</a></li>
						</ul>
					</li>
					<li><a href="#7-using-nodejs-client-with-hazelcast-imdg">7. Using Node.js Client with Hazelcast IMDG</a><ul>
							<li><a href="#71-nodejs-client-api-overview">7.1. Node.js Client API Overview</a></li>
							<li><a href="#72-nodejs-client-operation-modes">7.2. Node.js Client Operation Modes</a><ul>
									<li><a href="#721-smart-client">7.2.1. Smart Client</a></li>
									<li><a href="#722-unisocket-client">7.2.2. Unisocket Client</a></li>
								</ul>
							</li>
							<li><a href="#73-handling-failures">7.3. Handling Failures</a><ul>
									<li><a href="#731-handling-client-connection-failure">7.3.1. Handling Client Connection Failure</a></li>
									<li><a href="#732-handling-retry-able-operation-failure">7.3.2. Handling Retry-able Operation Failure</a></li>
								</ul>
							</li>
							<li><a href="#74-using-distributed-data-structures">7.4. Using Distributed Data Structures</a><ul>
									<li><a href="#741-using-map">7.4.1. Using Map</a></li>
									<li><a href="#742-using-multimap">7.4.2. Using MultiMap</a></li>
									<li><a href="#743-using-replicated-map">7.4.3. Using Replicated Map</a></li>
									<li><a href="#744-using-queue">7.4.4. Using Queue</a></li>
									<li><a href="#745-using-set">7.4.5. Using Set</a></li>
									<li><a href="#746-using-list">7.4.6. Using List</a></li>
									<li><a href="#747-using-ringbuffer">7.4.7. Using Ringbuffer</a></li>
									<li><a href="#748-using-reliable-topic">7.4.8. Using Reliable Topic</a></li>
									<li><a href="#749-using-lock">7.4.9. Using Lock</a></li>
									<li><a href="#7410-using-atomic-long">7.4.10. Using Atomic Long</a></li>
									<li><a href="#7411-using-semaphore">7.4.11. Using Semaphore</a></li>
									<li><a href="#7412-using-pn-counter">7.4.12. Using PN Counter</a></li>
									<li><a href="#7413-using-flake-id-generator">7.4.13. Using Flake ID Generator</a></li>
								</ul>
							</li>
							<li><a href="#75-distributed-events">7.5. Distributed Events</a><ul>
									<li><a href="#751-listening-for-cluster-events">7.5.1. Listening for Cluster Events</a><ul>
											<li><a href="#7511-membership-listener">7.5.1.1. Membership Listener</a></li>
											<li><a href="#7512-distributed-object-listener">7.5.1.2. Distributed Object Listener</a></li>
											<li><a href="#7513-lifecycle-listener">7.5.1.3. Lifecycle Listener</a></li>
										</ul>
									</li>
									<li><a href="#752-listening-for-distributed-data-structure-events">7.5.2. Listening for Distributed Data Structure Events</a><ul>
											<li><a href="#7521-map-listener">7.5.2.1. Map Listener</a></li>
											<li><a href="#7522-entry-listener">7.5.2.2. Entry Listener</a></li>
											<li><a href="#7523-item-listener">7.5.2.3. Item Listener</a></li>
											<li><a href="#7524-message-listener">7.5.2.4. Message Listener</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#76-distributed-computing">7.6. Distributed Computing</a><ul>
									<li><a href="#761-using-entryprocessor">7.6.1. Using EntryProcessor</a></li>
								</ul>
							</li>
							<li><a href="#77-distributed-query">7.7. Distributed Query</a><ul>
									<li><a href="#771-how-distributed-query-works">7.7.1. How Distributed Query Works</a><ul>
											<li><a href="#7711-employee-map-query-example">7.7.1.1. Employee Map Query Example</a></li>
											<li><a href="#7712-querying-by-combining-predicates-with-and-or-not">7.7.1.2. Querying by Combining Predicates with AND, OR, NOT</a></li>
											<li><a href="#7713-querying-with-sql">7.7.1.3. Querying with SQL</a></li>
											<li><a href="#7714-querying-with-json-strings">7.7.1.4. Querying with JSON Strings</a></li>
											<li><a href="#7715-filtering-with-paging-predicates">7.7.1.5. Filtering with Paging Predicates</a></li>
										</ul>
									</li>
									<li><a href="#772-fast-aggregations">7.7.2. Fast-Aggregations</a></li>
								</ul>
							</li>
							<li><a href="#78-performance">7.8. Performance</a><ul>
									<li><a href="#781-partition-aware">7.8.1. Partition Aware</a></li>
									<li><a href="#782-near-cache">7.8.2. Near Cache</a><ul>
											<li><a href="#7821-configuring-near-cache">7.8.2.1. Configuring Near Cache</a></li>
											<li><a href="#7822-near-cache-example-for-map">7.8.2.2. Near Cache Example for Map</a></li>
											<li><a href="#7823-near-cache-eviction">7.8.2.3. Near Cache Eviction</a></li>
											<li><a href="#7824-near-cache-expiration">7.8.2.4. Near Cache Expiration</a></li>
											<li><a href="#7825-near-cache-invalidation">7.8.2.5. Near Cache Invalidation</a></li>
											<li><a href="#7826-near-cache-eventual-consistency">7.8.2.6. Near Cache Eventual Consistency</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#79-monitoring-and-logging">7.9. Monitoring and Logging</a><ul>
									<li><a href="#791-enabling-client-statistics">7.9.1. Enabling Client Statistics</a></li>
									<li><a href="#792-logging-configuration">7.9.2. Logging Configuration</a></li>
								</ul>
							</li>
						</ul>
					</li>
					<li><a href="#8-development-and-testing">8. Development and Testing</a><ul>
							<li><a href="#81-building-and-using-client-from-sources">8.1. Building and Using Client From Sources</a></li>
							<li><a href="#82-testing">8.2. Testing</a></li>
						</ul>
					</li>
					<li><a href="#9-getting-help">9. Getting Help</a></li>
					<li><a href="#10-contributing">10. Contributing</a></li>
					<li><a href="#11-license">11. License</a></li>
					<li><a href="#12-copyright">12. Copyright</a></li>
				</ul>
				<h1 id="introduction">Introduction</h1>
				<p>This document provides information about the Node.js client for <a href="https://hazelcast.org/">Hazelcast</a>. This client uses Hazelcast&#39;s <a href="https://hazelcast.org/documentation/#open-binary">Open Client Protocol</a> and works with Hazelcast IMDG 3.6 and higher versions.</p>
				<h3 id="resources">Resources</h3>
				<p>See the following for more information on Node.js and Hazelcast IMDG:</p>
				<ul>
					<li>Hazelcast IMDG <a href="https://hazelcast.org/">website</a></li>
					<li>Hazelcast IMDG <a href="https://hazelcast.org/documentation/#imdg">Reference Manual</a></li>
					<li>About <a href="https://nodejs.org/en/about/">Node.js</a></li>
				</ul>
				<h3 id="release-notes">Release Notes</h3>
				<p>See the <a href="https://github.com/hazelcast/hazelcast-nodejs-client/releases">Releases</a> page of this repository.</p>
				<h1 id="1-getting-started">1. Getting Started</h1>
				<p>This chapter provides information on how to get started with your Hazelcast Node.js client. It outlines the requirements, installation and configuration of the client, setting up a cluster, and provides a simple application that uses a distributed map in Node.js client.</p>
				<h2 id="1-1-requirements">1.1. Requirements</h2>
				<ul>
					<li>Windows, Linux or MacOS</li>
					<li>Node.js 4 or newer</li>
					<li>Java 6 or newer</li>
					<li>Hazelcast IMDG 3.6 or newer</li>
					<li>Latest Hazelcast Node.js client</li>
				</ul>
				<h2 id="1-2-working-with-hazelcast-imdg-clusters">1.2. Working with Hazelcast IMDG Clusters</h2>
				<p>Hazelcast Node.js client requires a working Hazelcast IMDG cluster to run. This cluster handles storage and manipulation of the user data.
				Clients are a way to connect to the Hazelcast IMDG cluster and access such data.</p>
				<p>Hazelcast IMDG cluster consists of one or more cluster members. These members generally run on multiple virtual or physical machines
					and are connected to each other via network. Any data put on the cluster is partitioned to multiple members transparent to the user.
					It is therefore very easy to scale the system by adding new members as the data grows. Hazelcast IMDG cluster also offers resilience. Should
					any hardware or software problem causes a crash to any member, the data on that member is recovered from backups and the cluster
					continues to operate without any downtime. Hazelcast clients are an easy way to connect to a Hazelcast IMDG cluster and perform tasks on
				distributed data structures that live on the cluster.</p>
				<p>In order to use Hazelcast Node.js client, we first need to setup a Hazelcast IMDG cluster.</p>
				<h3 id="1-2-1-setting-up-a-hazelcast-imdg-cluster">1.2.1. Setting Up a Hazelcast IMDG Cluster</h3>
				<p>There are following options to start a Hazelcast IMDG cluster easily:</p>
				<ul>
					<li>You can run standalone members by downloading and running JAR files from the website.</li>
					<li>You can embed members to your Java projects.</li>
				</ul>
				<p>We are going to download JARs from the website and run a standalone member for this guide.</p>
				<h4 id="1-2-1-1-running-standalone-jars">1.2.1.1. Running Standalone JARs</h4>
				<p>Follow the instructions below to create a Hazelcast IMDG cluster:</p>
				<ol>
					<li>Go to Hazelcast&#39;s download <a href="https://hazelcast.org/download/">page</a> and download either the <code>.zip</code> or <code>.tar</code> distribution of Hazelcast IMDG.</li>
					<li>Decompress the contents into any directory that you
					want to run members from.</li>
					<li>Change into the directory that you decompressed the Hazelcast content and then into the <code>bin</code> directory.</li>
					<li>Use either <code>start.sh</code> or <code>start.bat</code> depending on your operating system. Once you run the start script, you should see the Hazelcast IMDG logs in the terminal.</li>
				</ol>
				<p>You should see a log similar to the following, which means that your 1-member cluster is ready to be used:</p>
				<pre><code><span class="hljs-attribute">INFO</span>: [192.168.0.3]:5701 [dev] [3.10.4]

<span class="less"><span class="hljs-selector-tag">Members</span> {<span class="hljs-attribute">size</span>:<span class="hljs-number">1</span>, <span class="hljs-attribute">ver</span>:<span class="hljs-number">1</span>} <span class="hljs-selector-attr">[
    Member [192.168.0.3]</span><span class="hljs-selector-pseudo">:5701</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">65dac4d1-2559-44bb-ba2e-ca41c56eedd6</span> <span class="hljs-selector-tag">this</span>
]

<span class="hljs-selector-tag">Sep</span> <span class="hljs-selector-tag">06</span>, <span class="hljs-selector-tag">2018</span> <span class="hljs-selector-tag">10</span><span class="hljs-selector-pseudo">:50</span><span class="hljs-selector-pseudo">:23</span> <span class="hljs-selector-tag">AM</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.hazelcast</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.LifecycleService</span>
<span class="hljs-selector-tag">INFO</span>: <span class="hljs-selector-attr">[192.168.0.3]</span><span class="hljs-selector-pseudo">:5701</span> <span class="hljs-selector-attr">[dev]</span> <span class="hljs-selector-attr">[3.10.4]</span> <span class="hljs-selector-attr">[192.168.0.3]</span><span class="hljs-selector-pseudo">:5701</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">STARTED</span></span>
</code></pre><h4 id="1-2-1-2-adding-user-library-to-classpath">1.2.1.2. Adding User Library to CLASSPATH</h4>
				<p>When you want to use features such as querying and language interoperability, you might need to add your own Java classes to the Hazelcast member in order to use them from your Node.js client. This can be done by adding your own compiled code to the <code>CLASSPATH</code>. To do this, compile your code with the <code>CLASSPATH</code> and add the compiled files to the <code>user-lib</code> directory in the extracted <code>hazelcast-&lt;version&gt;.zip</code> (or <code>tar</code>). Then, you can start your Hazelcast member by using the start scripts in the <code>bin</code> directory. The start scripts will automatically add your compiled classes to the <code>CLASSPATH</code>.</p>
				<p>Note that if you are adding an <code>IdentifiedDataSerializable</code> or a <code>Portable</code> class, you need to add its factory too. Then, you should configure the factory in the <code>hazelcast.xml</code> configuration file. This file resides in the <code>bin</code> directory where you extracted the <code>hazelcast-&lt;version&gt;.zip</code> (or <code>tar</code>).</p>
				<p>The following is an example configuration when you are adding an <code>IdentifiedDataSerializable</code> class:</p>
				<pre><code class="lang-xml">&lt;hazelcast&gt;
     ...
     &lt;serialization&gt;
        &lt;data-serializable-factories&gt;
            &lt;data-serializable-factory factory-id=&lt;identified-factory-id&gt;&gt;
                IdentifiedFactoryClassName
            &lt;/data-serializable-factory&gt;
        &lt;/data-serializable-factories&gt;
    &lt;/serialization&gt;
    ...
&lt;/hazelcast&gt;
</code></pre>
				<p>If you want to add a <code>Portable</code> class, you should use <code>&lt;portable-factories&gt;</code> instead of <code>&lt;data-serializable-factories&gt;</code> in the above configuration.</p>
				<p>See the <a href="http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#getting-started">Hazelcast IMDG Reference Manual</a> for more information on setting up the clusters.</p>
				<h2 id="1-3-downloading-and-installing">1.3. Downloading and Installing</h2>
				<p>Hazelcast Node.js client is on NPM. Just add <code>hazelcast-client</code> as a dependency to your Node.js project and you are good to go.</p>
				<pre><code>npm <span class="hljs-keyword">install</span> hazelcast-<span class="hljs-keyword">client</span> <span class="hljs-comment">--save</span>
</code></pre><h2 id="1-4-basic-configuration">1.4. Basic Configuration</h2>
				<p>If you are using Hazelcast IMDG and Node.js Client on the same computer, generally the default configuration should be fine. This is great for
					trying out the client. However, if you run the client on a different computer than any of the cluster members, you may
				need to do some simple configurations such as specifying the member addresses.</p>
				<p>The Hazelcast IMDG members and clients have their own configuration options. You may need to reflect some of the member side configurations on the client side to properly connect to the cluster.</p>
				<p>This section describes the most common configuration elements to get you started in no time.
					It discusses some member side configuration options to ease the understanding of Hazelcast&#39;s ecosystem. Then, the client side configuration options
				regarding the cluster connection are discussed. The configurations for the Hazelcast IMDG data structures that can be used in the Node.js client are discussed in the following sections.</p>
				<p>See the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html">Hazelcast IMDG Reference Manual</a> and <a href="#3-configuration-overview">Configuration Overview section</a> for more information.</p>
				<h3 id="1-4-1-configuring-hazelcast-imdg">1.4.1. Configuring Hazelcast IMDG</h3>
				<p>Hazelcast IMDG aims to run out-of-the-box for most common scenarios. However if you have limitations on your network such as multicast being disabled,
				you may have to configure your Hazelcast IMDG members so that they can find each other on the network. Also, since most of the distributed data structures are configurable, you may want to configure them according to your needs. We will show you the basics about network configuration here.</p>
				<p>You can use the following options to configure Hazelcast IMDG:</p>
				<ul>
					<li>Using the <code>hazelcast.xml</code> configuration file.</li>
					<li>Programmatically configuring the member before starting it from the Java code.</li>
				</ul>
				<p>Since we use standalone servers, we will use the <code>hazelcast.xml</code> file to configure our cluster members.</p>
				<p>When you download and unzip <code>hazelcast-&lt;version&gt;.zip</code> (or <code>tar</code>), you see the <code>hazelcast.xml</code> in the <code>bin</code> directory. When a Hazelcast member starts, it looks for the <code>hazelcast.xml</code> file to load the configuration from. A sample <code>hazelcast.xml</code> is shown below.</p>
				<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hazelcast</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">group</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>dev-pass<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">group</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">network</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">port</span> <span class="hljs-attr">auto-increment</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">port-count</span>=<span class="hljs-string">"100"</span>&gt;</span>5701<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">join</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">multicast</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"true"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">multicast-group</span>&gt;</span>224.2.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">multicast-group</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">multicast-port</span>&gt;</span>54327<span class="hljs-tag">&lt;/<span class="hljs-name">multicast-port</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">multicast</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tcp-ip</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"false"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">interface</span>&gt;</span>127.0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">interface</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">member-list</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">member</span>&gt;</span>127.0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">member</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">member-list</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tcp-ip</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">join</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ssl</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"false"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">network</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">partition-group</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"false"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"default"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">backup-count</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">backup-count</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hazelcast</span>&gt;</span>
</code></pre>
				<p>We will go over some important configuration elements in the rest of this section.</p>
				<ul>
					<li><code>&lt;group&gt;</code>: Specifies which cluster this member belongs to. A member connects only to the other members that are in the same group as
						itself. As shown in the above configuration sample, there are <code>&lt;name&gt;</code> and <code>&lt;password&gt;</code> tags under the <code>&lt;group&gt;</code> element with some pre-configured values. You may give your clusters different names so that they can
						live in the same network without disturbing each other. Note that the cluster name should be the same across all members and clients that belong
						to the same cluster. The <code>&lt;password&gt;</code> tag is not in use since Hazelcast 3.9. It is there for backward compatibility
					purposes. You can remove or leave it as it is if you use Hazelcast 3.9 or later.</li>
					<li><code>&lt;network&gt;</code><ul>
							<li><code>&lt;port&gt;</code>: Specifies the port number to be used by the member when it starts. Its default value is 5701. You can specify another port number, and if
							you set <code>auto-increment</code> to <code>true</code>, then Hazelcast will try the subsequent ports until it finds an available port or the <code>port-count</code> is reached.</li>
							<li><code>&lt;join&gt;</code>: Specifies the strategies to be used by the member to find other cluster members. Choose which strategy you want to
								use by setting its <code>enabled</code> attribute to <code>true</code> and the others to <code>false</code>.<ul>
									<li><code>&lt;multicast&gt;</code>: Members find each other by sending multicast requests to the specified address and port. It is very useful if IP addresses
									of the members are not static.</li>
									<li><code>&lt;tcp&gt;</code>: This strategy uses a pre-configured list of known members to find an already existing cluster. It is enough for a member to
										find only one cluster member to connect to the cluster. The rest of the member list is automatically retrieved from that member. We recommend
										putting multiple known member addresses there to avoid disconnectivity should one of the members in the list is unavailable at the time
									of connection.</li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
				<p>These configuration elements are enough for most connection scenarios. Now we will move onto the configuration of the Node.js client.</p>
				<h3 id="1-4-2-configuring-hazelcast-node-js-client">1.4.2. Configuring Hazelcast Node.js Client</h3>
				<p>There are two ways to configure a Hazelcast Node.js client:</p>
				<ul>
					<li>Programmatically</li>
					<li>Declaratively (JSON)</li>
				</ul>
				<p>This section describes some network configuration settings to cover common use cases in connecting the client to a cluster. See the <a href="#3-configuration-overview">Configuration Overview section</a>
				and the following sections for information about detailed network configurations and/or additional features of Hazelcast Node.js client configuration.</p>
				<p>An easy way to configure your Hazelcast Node.js client is to create a <code>ClientConfig</code> object and set the appropriate options. Then you can
					supply this object to your client at the startup. This is the programmatic configuration approach. Another way to configure your client, which is the declarative approach, is to provide a <code>hazelcast-client.json</code> file. This is similar to the <code>hazelcast.xml</code> approach
					in configuring the member. Note that <code>hazelcast-client.json</code> is a JSON file whereas the member configuration is XML based. Although these
					two formats are different, you will realize that the names of configuration parameters are the same for both the client and member.
				It is done this way to make it easier to transfer Hazelcast skills to multiple platforms.</p>
				<p>Once you embedded <code>hazelcast-client</code> to your Node.js project, you may follow any of programmatic or declarative configuration approaches.
				We will provide both ways for each configuration option in this section. Pick one way and stick to it.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<p>You need to create a <code>ClientConfig</code> object and adjust its properties. Then you can pass this object to the client when starting it.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> Client = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Client;
<span class="hljs-keyword">let</span> Config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Config;
<span class="hljs-keyword">let</span> config = <span class="hljs-keyword">new</span> Config.ClientConfig();
Client.newHazelcastClient(config).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">client</span>) </span>{
    <span class="hljs-comment">// some operations</span>
});
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<p>Hazelcast Node.js client looks for a <code>hazelcast-client.json</code> in the current working directory unless you provide a configuration object
					at the startup. If you intend to configure your client using a configuration file, then place a <code>hazelcast-client.json</code> in the directory
				of your application&#39;s entry point.</p>
				<p>If you prefer to keep your <code>hazelcast-client.json</code> file somewhere else, you can override the environment variable <code>HAZELCAST_CLIENT_CONFIG</code>
				with the location of your config file. In this case, the client uses the configuration file specified in the environment variable.</p>
				<p>For the structure of <code>hazelcast-client.json</code>, see the <a href="hazelcast-client-full.json">hazelcast-client-full.json file</a>. You
					can use only the relevant parts of the file in your <code>hazelcast-client.json</code> and remove the rest. The default configuration is used for any
				part that you do not explicitly set in the <code>hazelcast-client.json</code> file.</p>
				<hr>
				<p>If you run the Hazelcast IMDG members in a different server than the client, you most probably have configured the members&#39; ports and cluster
				names as explained in the previous section. If you did, then you need to make certain changes to the network settings of your client.</p>
				<h4 id="1-4-2-1-group-settings">1.4.2.1. Group Settings</h4>
				<p>You need to provide the group name of the cluster, if it is defined on the server side, to which you want the client to connect.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> cfg = <span class="hljs-keyword">new</span> Config.ClientConfig();
cfg.group.name = <span class="hljs-string">'group name of your cluster'</span>
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"group"</span>: {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"group name of your cluster"</span>
    }
}
</code></pre>
				<blockquote>
					<p><strong>NOTE: If you have a Hazelcast IMDG release older than 3.11, you need to provide also a group password along with the group name.</strong></p>
				</blockquote>
				<h4 id="1-4-2-2-network-settings">1.4.2.2. Network Settings</h4>
				<p>You need to provide the IP address and port of at least one member in your cluster so the client can find it.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> cfg = <span class="hljs-keyword">new</span> Config.ClientConfig();
cfg.network.addresses.push(<span class="hljs-string">'some-ip-address:port'</span>);
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"clusterMembers"</span>: [
            <span class="hljs-string">"some-ip-address:port"</span>
        ],
    }
}
</code></pre>
				<h2 id="1-5-basic-usage">1.5. Basic Usage</h2>
				<p>Now that we have a working cluster and we know how to configure both our cluster and client, we can run a simple program to use a
				distributed map in the Node.js client.</p>
				<p>The following example first creates a programmatic configuration object. Then, it starts a client.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> Client = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Client;
<span class="hljs-keyword">let</span> Config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Config;
<span class="hljs-keyword">let</span> config = <span class="hljs-keyword">new</span> Config.ClientConfig(); <span class="hljs-comment">// We create a config for illustrative purposes.</span>
                                        <span class="hljs-comment">// We do not adjust this config. Therefore it has default settings.</span>

Client.newHazelcastClient(config).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">client</span>) </span>{
    <span class="hljs-built_in">console</span>.log(client.getLocalEndpoint()); <span class="hljs-comment">// Connects and prints some information about this client</span>
});
</code></pre>
				<p>This should print logs about the cluster members and information about the client itself such as the client type, UUID and address.</p>
				<pre><code><span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">LifecycleService:</span> <span class="hljs-string">HazelcastClient</span> <span class="hljs-string">is</span> <span class="hljs-string">starting</span>
<span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">ConnectionAuthenticator:</span> <span class="hljs-string">Connection</span> <span class="hljs-string">to</span> <span class="hljs-number">10.216</span><span class="hljs-number">.1</span><span class="hljs-number">.43</span><span class="hljs-string">:5701</span> <span class="hljs-string">authenticated</span>
<span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">ClusterService:</span> <span class="hljs-string">Members</span> <span class="hljs-string">received.</span>
<span class="hljs-string">[</span> <span class="hljs-string">Member</span> <span class="hljs-string">{</span>
<span class="hljs-attr">    address:</span> <span class="hljs-string">Address</span> <span class="hljs-string">{</span> <span class="hljs-attr">host:</span> <span class="hljs-string">'10.216.1.43'</span><span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5701</span><span class="hljs-string">,</span> <span class="hljs-attr">type:</span> <span class="hljs-number">4</span> <span class="hljs-string">},</span>
<span class="hljs-attr">    uuid:</span> <span class="hljs-string">'7961eef2-940d-42dc-8036-2a29c5c9942c'</span><span class="hljs-string">,</span>
<span class="hljs-attr">    isLiteMember:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
<span class="hljs-attr">    attributes:</span> <span class="hljs-string">{}</span> <span class="hljs-string">}</span> <span class="hljs-string">]</span>
<span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">LifecycleService:</span> <span class="hljs-string">HazelcastClient</span> <span class="hljs-string">is</span> <span class="hljs-string">started</span>
<span class="hljs-string">ClientInfo</span> <span class="hljs-string">{</span>
<span class="hljs-attr">  type:</span> <span class="hljs-string">'NodeJS'</span><span class="hljs-string">,</span>
<span class="hljs-attr">  uuid:</span> <span class="hljs-string">'8618226d-0e7b-4442-b9c2-a5918a3d3db2'</span><span class="hljs-string">,</span>
<span class="hljs-attr">  localAddress:</span> <span class="hljs-string">Address</span> <span class="hljs-string">{</span> <span class="hljs-attr">host:</span> <span class="hljs-string">'127.0.0.1'</span><span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">54708</span><span class="hljs-string">,</span> <span class="hljs-attr">type:</span> <span class="hljs-number">4</span> <span class="hljs-string">}</span> <span class="hljs-string">}</span>
</code></pre><p>Congratulations! You just started a Hazelcast Node.js client.</p>
				<p><strong>Using a Map</strong></p>
				<p>Let&#39;s manipulate a distributed map on a cluster using the client.</p>
				<p>Save the following file as <code>IT.js</code> and run it using <code>node IT.js</code>.</p>
				<p><strong>IT.js</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> Client = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Client;
<span class="hljs-keyword">let</span> Config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Config;
<span class="hljs-keyword">let</span> config = <span class="hljs-keyword">new</span> Config.ClientConfig();

Client.newHazelcastClient(config).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>{
    <span class="hljs-keyword">var</span> personnelMap;
    <span class="hljs-keyword">return</span> client.getMap(<span class="hljs-string">'personnelMap'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
        personnelMap = mp;
        <span class="hljs-keyword">return</span> personnelMap.put(<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'IT'</span>);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> personnelMap.put(<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'IT'</span>);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> personnelMap.put(<span class="hljs-string">'Clark'</span>, <span class="hljs-string">'IT'</span>);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Added IT personnel. Logging all known personnel"</span>);
        <span class="hljs-keyword">return</span> personnelMap.entrySet();
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">allPersonnel</span>) </span>{
        allPersonnel.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">person</span>) </span>{
            <span class="hljs-built_in">console</span>.log(person[<span class="hljs-number">0</span>] + <span class="hljs-string">' is in '</span> + person[<span class="hljs-number">1</span>] + <span class="hljs-string">' department'</span>);
        });
        <span class="hljs-keyword">return</span> client.shutdown();
    });
});
</code></pre>
				<p><strong>Output</strong></p>
				<pre><code>Added IT personnel.<span class="hljs-built_in"> Logging </span>all known personnel
Alice is <span class="hljs-keyword">in</span> IT department
Clark is <span class="hljs-keyword">in</span> IT department
Bob is <span class="hljs-keyword">in</span> IT department
</code></pre><p>You see this example puts all the IT personnel into a cluster-wide <code>personnelMap</code> and then prints all the known personnel.</p>
				<p>Now create a <code>Sales.js</code> file as shown below and run it using <code>node Sales.js</code>.</p>
				<p><strong>Sales.js</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> Client = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Client;
<span class="hljs-keyword">let</span> Config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Config;
<span class="hljs-keyword">let</span> config = <span class="hljs-keyword">new</span> Config.ClientConfig();

Client.newHazelcastClient(config).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>{
    <span class="hljs-keyword">var</span> personnelMap;
    <span class="hljs-keyword">return</span> client.getMap(<span class="hljs-string">'personnelMap'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
        personnelMap = mp;
        <span class="hljs-keyword">return</span> personnelMap.put(<span class="hljs-string">'Denise'</span>, <span class="hljs-string">'Sales'</span>);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> personnelMap.put(<span class="hljs-string">'Erwing'</span>, <span class="hljs-string">'Sales'</span>);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> personnelMap.put(<span class="hljs-string">'Faith'</span>, <span class="hljs-string">'Sales'</span>);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Added Sales personnel. Logging all known personnel"</span>);
        <span class="hljs-keyword">return</span> personnelMap.entrySet();
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">allPersonnel</span>) </span>{
        allPersonnel.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">person</span>) </span>{
            <span class="hljs-built_in">console</span>.log(person[<span class="hljs-number">0</span>] + <span class="hljs-string">' is in '</span> + person[<span class="hljs-number">1</span>] + <span class="hljs-string">' department'</span>);
        });
        <span class="hljs-keyword">return</span> client.shutdown();
    });
});
</code></pre>
				<p><strong>Output</strong></p>
				<pre><code>Added Sales personnel.<span class="hljs-built_in"> Logging </span>all known personnel
Denise is <span class="hljs-keyword">in</span> Sales department
Erwing is <span class="hljs-keyword">in</span> Sales department
Faith is <span class="hljs-keyword">in</span> Sales department
Alice is <span class="hljs-keyword">in</span> IT department
Clark is <span class="hljs-keyword">in</span> IT department
Bob is <span class="hljs-keyword">in</span> IT department
</code></pre><p>You will see this time we add only the sales employees but we get the list all known employees including the ones in IT.
				That is because our map lives in the cluster and no matter which client we use, we can access the whole map.</p>
				<h2 id="1-6-code-samples">1.6. Code Samples</h2>
				<p>See the Hazelcast Node.js <a href="https://github.com/hazelcast/hazelcast-nodejs-client/tree/master/code_samples">code samples</a> for more examples.</p>
				<p>You can also see the Hazelcast Node.js <a href="http://hazelcast.github.io/hazelcast-nodejs-client/api/current/docs/">API Documentation</a>.</p>
				<h1 id="2-features">2. Features</h1>
				<p>Hazelcast Node.js client supports the following data structures and features:</p>
				<ul>
					<li>Map</li>
					<li>Queue</li>
					<li>Set</li>
					<li>List</li>
					<li>MultiMap</li>
					<li>Replicated Map</li>
					<li>Ringbuffer</li>
					<li>Reliable Topic</li>
					<li>Lock</li>
					<li>Semaphore</li>
					<li>Atomic Long</li>
					<li>CRDT PN Counter</li>
					<li>Flake Id Generator</li>
					<li>Event Listeners</li>
					<li>Entry Processor</li>
					<li>Query (Predicates)</li>
					<li>Paging Predicate</li>
					<li>Built-in Predicates</li>
					<li>Listener with Predicate</li>
					<li>Fast Aggregations</li>
					<li>Near Cache Support</li>
					<li>Eventual Consistency Control</li>
					<li>Declarative Configuration (JSON)</li>
					<li>Programmatic Configuration</li>
					<li>Client Configuration Import</li>
					<li>Fail Fast on Invalid Configuration</li>
					<li>SSL Support (requires Enterprise server)</li>
					<li>Mutual Authentication (requires Enterprise server)</li>
					<li>Authorization</li>
					<li>Smart Client</li>
					<li>Unisocket Client</li>
					<li>Lifecycle Service</li>
					<li>Hazelcast Cloud Discovery</li>
					<li>IdentifiedDataSerializable Serialization</li>
					<li>Portable Serialization</li>
					<li>Custom Serialization</li>
					<li>Global Serialization</li>
				</ul>
				<h1 id="3-configuration-overview">3. Configuration Overview</h1>
				<p>This chapter describes the options to configure your Node.js client and explains how you can import multiple configurations
				and how you should set paths and exported names for the client to load objects.</p>
				<h2 id="3-1-configuration-options">3.1. Configuration Options</h2>
				<p>You can configure the Hazelcast Node.js client declaratively (JSON) or programmatically (API).</p>
				<h3 id="3-1-1-programmatic-configuration">3.1.1. Programmatic Configuration</h3>
				<p>For programmatic configuration of the Hazelcast Node.js client, just instantiate a <code>ClientConfig</code> object and configure the
				desired aspects. An example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Config;
<span class="hljs-keyword">var</span> cfg = <span class="hljs-keyword">new</span> Config.ClientConfig();
cfg.networkConfig.addresses.push(<span class="hljs-string">'127.0.0.1:5701'</span>);
HazelcastClient.newHazelcastClient(cfg).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>{
    <span class="hljs-comment">// some operations</span>
});
</code></pre>
				<p>See the <code>ClientConfig</code> class documentation at <a href="http://hazelcast.github.io/hazelcast-nodejs-client/api/current/docs">Hazelcast Node.js Client API Docs</a> for details.</p>
				<h3 id="3-1-2-declarative-configuration-json-">3.1.2. Declarative Configuration (JSON)</h3>
				<p>If the client is not supplied with a programmatic configuration at the time of initialization, it will look for a configuration file named <code>hazelcast-client.json</code>. If this file exists, then the configuration is loaded from it. Otherwise, the client will start with the default configuration. The following are the places that the client looks for a <code>hazelcast-client.json</code> in the given order:</p>
				<ol>
					<li>Environment variable: The client first looks for the environment variable <code>HAZELCAST_CLIENT_CONFIG</code>. If it exists,
					the client looks for the configuration file in the specified location.</li>
					<li>Current working directory: If there is no environment variable set, the client tries to load <code>hazelcast-client.json</code>
					from the current working directory.</li>
					<li>Default configuration: If all of the above methods fail, the client starts with the default configuration.
						The default configuration is programmatic. If you want to override the default configuration declaratively, you need to create
					a <code>hazelcast-client.json</code> file in your working directory. To get an idea about the structure of this configuration file, see <a href="hazelcast-client-default.json">hazelcast-client-default.json</a> and <a href="hazelcast-client-full.json">hazelcast-client-full.json</a>.</li>
				</ol>
				<p>Following is a sample JSON configuration file:</p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"group"</span>: {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"hazel"</span>,
        <span class="hljs-attr">"password"</span>: <span class="hljs-string">"cast"</span>
    },
    <span class="hljs-attr">"properties"</span>: {
        <span class="hljs-attr">"hazelcast.client.heartbeat.timeout"</span>: <span class="hljs-number">10000</span>,
        <span class="hljs-attr">"hazelcast.client.invocation.retry.pause.millis"</span>: <span class="hljs-number">4000</span>,
        <span class="hljs-attr">"hazelcast.client.invocation.timeout.millis"</span>: <span class="hljs-number">180000</span>,
        <span class="hljs-attr">"hazelcast.invalidation.reconciliation.interval.seconds"</span>: <span class="hljs-number">50</span>,
        <span class="hljs-attr">"hazelcast.invalidation.max.tolerated.miss.count"</span>: <span class="hljs-number">15</span>,
        <span class="hljs-attr">"hazelcast.invalidation.min.reconciliation.interval.seconds"</span>: <span class="hljs-number">60</span>
    },
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"clusterMembers"</span>: [
            <span class="hljs-string">"127.0.0.1:5701"</span>
        ],
        <span class="hljs-attr">"smartRouting"</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">"connectionTimeout"</span>: <span class="hljs-number">6000</span>,
        <span class="hljs-attr">"connectionAttemptPeriod"</span>: <span class="hljs-number">4000</span>,
        <span class="hljs-attr">"connectionAttemptLimit"</span>: <span class="hljs-number">3</span>
    }
}
</code></pre>
				<p>In the following chapters you will learn the description of all elements included in a JSON configuration file used to configure Hazelcast Node.js client.</p>
				<h2 id="3-2-importing-multiple-configurations">3.2. Importing Multiple Configurations</h2>
				<p>You can compose the declarative configuration of your Node.js client from multiple declarative
					configuration snippets. In order to compose a declarative configuration, you can use the <code>import</code> element to load
				different declarative configuration files.</p>
				<p>Let&#39;s assume you have the following two configurations:</p>
				<p><code>group-config.json</code>:</p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"group"</span>: {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"hazel"</span>,
        <span class="hljs-attr">"password"</span>: <span class="hljs-string">"cast"</span>
    }
}
</code></pre>
				<p><code>network-config.json</code>:</p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"clusterMembers"</span>: [
            <span class="hljs-string">"127.0.0.10:4001"</span>,
            <span class="hljs-string">"127.0.0.11:4001"</span>
        ]
    }
}
</code></pre>
				<p>To get your example client configuration out of the above two, use the <code>import</code> element as
				shown below.</p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"import"</span>: [
        <span class="hljs-string">"group-config.json"</span>,
        <span class="hljs-string">"network-config.json"</span>
    ]
}
</code></pre>
				<blockquote>
					<p>Note: Use <code>import</code> element on top level of JSON hierarchy.</p>
				</blockquote>
				<h2 id="3-3-loading-objects-and-path-resolution">3.3. Loading Objects and Path Resolution</h2>
				<p>For configuration elements that require you to specify a code piece, you will need to specify the path to the
				code and name of the exported element that you want the client to use. This configuration is set as follows:</p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"path"</span>: <span class="hljs-string">"path/to/file"</span>,
    <span class="hljs-attr">"exportedName"</span>: <span class="hljs-string">"MyObject"</span>
}
</code></pre>
				<p>In the above configuration, <code>path</code> shows the address to the file that you want the client to load. Unless this is an
				absolute path, it is relative to the location of <code>hazelcast-config.json</code> file.</p>
				<p>In Javascript, you can define and export as many objects as you want in a single file. Above configuration element
				is designed to load only one specified object from a file (<code>MyObject</code>). Therefore, <code>exportedName</code> specifies the name of desired object.</p>
				<p>Let&#39;s say your project&#39;s directory structure is as follows:</p>
				<pre><code>my_app/
my_app/index<span class="hljs-selector-class">.js</span>
my_app/factory_utils<span class="hljs-selector-class">.js</span>
my_app/hazelcast-client<span class="hljs-selector-class">.json</span>
my_app/node_modules/
my_app/node_modules/hazelcast-client
</code></pre><p>In the <code>factory_utils.js</code> file, you have multiple exported functions:</p>
				<pre><code class="lang-javascript">exports.utilityFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{...}
exports.MySSLFactory = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{...}
</code></pre>
				<p>In order to load <code>MySSLFactory</code> in your SSL configuration, you should set <code>path</code> and <code>exportedName</code> as <code>factory_utils.js</code>
				and <code>MySSLFactory</code>, respectively.</p>
				<p>If you have only one export as the default export from <code>factory_utils.js</code>, just skip the <code>exportedName</code> property and
				the client will load the default export from the file.</p>
				<h1 id="4-serialization">4. Serialization</h1>
				<p>Serialization is the process of converting an object into a stream of bytes to store the object in the memory, a file or database, or transmit it through the network. Its main purpose is to save the state of an object in order to be able to recreate it when needed. The reverse process is called deserialization. Hazelcast offers you its own native serialization methods. You will see these methods throughout this chapter.</p>
				<p>Hazelcast serializes all your objects before sending them to the server. The <code>boolean</code>, <code>number</code>,<code>string</code> and <code>Long</code> types are serialized natively and you cannot override this behavior. The following table is the conversion of types for the Java server side.</p>
				<table>
					<thead>
						<tr>
							<th>Node.js</th>
							<th>Java</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>boolean</td>
							<td>Boolean</td>
						</tr>
						<tr>
							<td>number</td>
							<td>Byte, Short, Integer, Float, Double</td>
						</tr>
						<tr>
							<td>string</td>
							<td>String</td>
						</tr>
						<tr>
							<td>Long</td>
							<td>Long</td>
						</tr>
					</tbody>
				</table>
				<blockquote>
					<p>Note: A <code>number</code> type is serialized as <code>Double</code> by default. You can configure this behavior using the <code>SerializationConfig.defaultNumberType</code> method.</p>
				</blockquote>
				<p>Arrays of the above types can be serialized as <code>boolean[]</code>, <code>byte[]</code>, <code>short[]</code>, <code>int[]</code>, <code>float[]</code>, <code>double[]</code>, <code>long[]</code> and <code>string[]</code> for the Java server side, respectively.</p>
				<p><strong>Serialization Priority</strong></p>
				<p>When Hazelcast Node.js client serializes an object:</p>
				<ol>
					<li><p>It first checks whether the object is null.</p>
					</li>
					<li><p>If the above check fails, then it checks if it is an instance of <code>IdentifiedDataSerializable</code>.</p>
					</li>
					<li><p>If the above check fails, then it checks if it is an instance of <code>Portable</code>.</p>
					</li>
					<li><p>If the above check fails, then it checks if it is an instance of one of the default types (see above default types).</p>
					</li>
					<li><p>If the above check fails, then it looks for a user-specified <a href="#43-custom-serialization">Custom Serialization</a>.</p>
					</li>
					<li><p>If the above check fails, it will use the registered <a href="#44-global-serialization">Global Serialization</a> if one exists.</p>
					</li>
					<li><p>If the above check fails, then the Node.js client uses <code>JSON Serialization</code> by default.</p>
					</li>
				</ol>
				<p>However, <code>JSON Serialization</code> is not the best way of serialization in terms of performance and interoperability between the clients in different languages. If you want the serialization to work faster or you use the clients in different languages, Hazelcast offers its own native serialization methods, such as <a href="#41-identifieddataserializable-serialization"><code>IdentifiedDataSerializable</code> Serialization</a> and <a href="#42-portable-serialization"><code>Portable</code> Serialization</a>.</p>
				<p>Or, if you want to use your own serialization method, you can use a <a href="#43-custom-serialization">Custom Serialization</a>.</p>
				<blockquote>
					<p><strong>NOTE: Hazelcast Node.js client is a TypeScript-based project but JavaScript does not have interfaces. Therefore,
					some interfaces are given to the user by using the TypeScript files that have <code>.ts</code> extension. In this guide, implementing an interface means creating an object to have the necessary functions that are listed in the interface inside the <code>.ts</code> file. Also, this object is mentioned as <code>an instance of the interface</code>. You can search the <a href="http://hazelcast.github.io/hazelcast-nodejs-client/api/current/docs/">API Documentation</a> or GitHub repository for a required interface.</strong></p>
				</blockquote>
				<h2 id="4-1-identifieddataserializable-serialization">4.1. IdentifiedDataSerializable Serialization</h2>
				<p>For a faster serialization of objects, Hazelcast recommends to implement the <code>IdentifiedDataSerializable</code> interface. The following is an example of an object implementing this interface:</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">id, name</span>) </span>{
    <span class="hljs-keyword">this</span>.id = id;
    <span class="hljs-keyword">this</span>.name = name;
}

Employee.prototype.readData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">input</span>) </span>{
    <span class="hljs-keyword">this</span>.id = input.readInt();
    <span class="hljs-keyword">this</span>.name = input.readUTF();
};

Employee.prototype.writeData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">output</span>) </span>{
    output.writeInt(<span class="hljs-keyword">this</span>.id);
    output.writeUTF(<span class="hljs-keyword">this</span>.name);
};

Employee.prototype.getFactoryId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;
};

Employee.prototype.getClassId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;
};

Employee.prototype.getClassId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.classId;
};
</code></pre>
				<p>The <code>IdentifiedDataSerializable</code> interface uses <code>getClassId()</code> and <code>getFactoryId()</code> to reconstitute the object. To complete the implementation, <code>IdentifiedDataSerializableFactory</code> should also be implemented and registered into <code>SerializationConfig</code> which can be accessed from <code>Config.serializationConfig</code>. The factory&#39;s responsibility is to return an instance of the right <code>IdentifiedDataSerializable</code> object, given the <code>classId</code>.</p>
				<p>A sample <code>IdentifiedDataSerializableFactory</code> could be implemented as follows:</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SampleDataSerializableFactory</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Constructor function</span>
}

SampleDataSerializableFactory.prototype.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>{
    <span class="hljs-keyword">if</span> (type === <span class="hljs-number">100</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Employee();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};
</code></pre>
				<p>The last step is to register the <code>IdentifiedDataSerializableFactory</code> to the <code>SerializationConfig</code>.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-keyword">new</span> Config.ClientConfig();
config.serializationConfig.dataSerializableFactories[<span class="hljs-number">1000</span>] = <span class="hljs-keyword">new</span> SampleDataSerializableFactory();
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"serialization"</span>: {
        <span class="hljs-attr">"dataSerializableFactories"</span>: [
            {
                <span class="hljs-attr">"path"</span>: <span class="hljs-string">"factory.js"</span>,
                <span class="hljs-attr">"exportedName"</span>: <span class="hljs-string">"SampleDataSerializableFactory"</span>,
                <span class="hljs-attr">"factoryId"</span>: <span class="hljs-number">1000</span>
            }
        ]
    }
}
</code></pre>
				<p>Note that the ID that is passed to the <code>SerializationConfig</code> is same as the <code>factoryId</code> that the <code>Employee</code> object returns.</p>
				<h2 id="4-2-portable-serialization">4.2. Portable Serialization</h2>
				<p>As an alternative to the existing serialization methods, Hazelcast offers portable serialization. To use it, you need to implement the <code>Portable</code> interface. Portable serialization has the following advantages:</p>
				<ul>
					<li>Supporting multiversion of the same object type.</li>
					<li>Fetching individual fields without having to rely on the reflection.</li>
					<li>Querying and indexing support without deserialization and/or reflection.</li>
				</ul>
				<p>In order to support these features, a serialized <code>Portable</code> object contains meta information like the version and concrete location of the each field in the binary data. This way Hazelcast is able to navigate in the binary data and deserialize only the required field without actually deserializing the whole object which improves the query performance.</p>
				<p>With multiversion support, you can have two members where each of them having different versions of the same object, and Hazelcast will store both meta information and use the correct one to serialize and deserialize portable objects depending on the member. This is very helpful when you are doing a rolling upgrade without shutting down the cluster.</p>
				<p>Also note that portable serialization is totally language independent and is used as the binary protocol between Hazelcast server and clients.</p>
				<p>A sample portable implementation of a <code>Customer</code> class looks like the following:</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Customer</span>(<span class="hljs-params">name, id, lastOrder</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name;
    <span class="hljs-keyword">this</span>.id = id;
    <span class="hljs-keyword">this</span>.lastOrder = lastOrder;
    <span class="hljs-keyword">this</span>.classId = <span class="hljs-number">1</span>;
}

Customer.prototype.readPortable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reader</span>) </span>{
    <span class="hljs-keyword">this</span>.name = reader.readUTF(<span class="hljs-string">'name'</span>);
    <span class="hljs-keyword">this</span>.id = reader.readInt(<span class="hljs-string">'id'</span>);
    <span class="hljs-keyword">this</span>.lastOrder = reader.readLong(<span class="hljs-string">'lastOrder'</span>).toNumber();
};

Customer.prototype.writePortable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">writer</span>) </span>{
    writer.writeUTF(<span class="hljs-string">'name'</span>, <span class="hljs-keyword">this</span>.name);
    writer.writeInt(<span class="hljs-string">'id'</span>, <span class="hljs-keyword">this</span>.id);
    writer.writeLong(<span class="hljs-string">'lastOrder'</span>, Long.fromNumber(<span class="hljs-keyword">this</span>.lastOrder));
};

Customer.prototype.getFactoryId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> PortableFactory.factoryId;
};

Customer.prototype.getClassId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.classId;
};
</code></pre>
				<p>Similar to <code>IdentifiedDataSerializable</code>, a <code>Portable</code> object must provide <code>classId</code> and <code>factoryId</code>. The factory object will be used to create the <code>Portable</code> object given the <code>classId</code>.</p>
				<p>A sample <code>PortableFactory</code> could be implemented as follows:</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PortableFactory</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Constructor function</span>
}

PortableFactory.prototype.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">classId</span>) </span>{
    <span class="hljs-keyword">if</span> (classId === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Customer();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};
</code></pre>
				<p>The last step is to register the <code>PortableFactory</code> to the <code>SerializationConfig</code>.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-keyword">new</span> Config.ClientConfig();
config.serializationConfig.portableFactories[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> PortableFactory();
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"serialization"</span>: {
        <span class="hljs-attr">"portableFactories"</span>: [
            {
                <span class="hljs-attr">"path"</span>: <span class="hljs-string">"factory.js"</span>,
                <span class="hljs-attr">"exportedName"</span>: <span class="hljs-string">"PortableFactory"</span>,
                <span class="hljs-attr">"factoryId"</span>: <span class="hljs-number">1</span>
            }
        ]
    }
}
</code></pre>
				<p>Note that the ID that is passed to the <code>SerializationConfig</code> is same as the <code>factoryId</code> that <code>Customer</code> object returns.</p>
				<h2 id="4-3-custom-serialization">4.3. Custom Serialization</h2>
				<p>Hazelcast lets you plug a custom serializer to be used for serialization of objects.</p>
				<p>Let&#39;s say you have an object <code>CustomSerializable</code> and you would like to customize the serialization, since you may want to use an external serializer for only one object.</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomSerializable</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">this</span>.value = value;
}

CustomSerializable.prototype.hzGetCustomId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
};
</code></pre>
				<p>Let&#39;s say your custom <code>CustomSerializer</code> will serialize <code>CustomSerializable</code>.</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomSerializer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Constructor function</span>
}

CustomSerializer.prototype.getId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;
};

CustomSerializer.prototype.write = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">output, t</span>) </span>{
    output.writeInt(t.value.length);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; t.value.length; i++) {
        output.writeInt(t.value.charCodeAt(i));
    }
};

CustomSerializer.prototype.read = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reader</span>) </span>{
    <span class="hljs-keyword">var</span> len = reader.readInt();
    <span class="hljs-keyword">var</span> str = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        str = str + <span class="hljs-built_in">String</span>.fromCharCode(reader.readInt());
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomSerializable(str);
};
</code></pre>
				<p>Note that the serializer <code>id</code> must be unique as Hazelcast will use it to lookup the <code>CustomSerializer</code> while it deserializes the object. Now the last required step is to register the <code>CustomSerializer</code> to the configuration.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-keyword">new</span> Config.ClientConfig();
config.serializationConfig.customSerializers.push(<span class="hljs-keyword">new</span> CustomSerializer());
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"serialization"</span>: {
        <span class="hljs-attr">"defaultNumberType"</span>: <span class="hljs-string">"integer"</span>,
        <span class="hljs-attr">"isBigEndian"</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">"serializers"</span>: [
            {
                <span class="hljs-attr">"path"</span>: <span class="hljs-string">"custom.js"</span>,
                <span class="hljs-attr">"exportedName"</span>: <span class="hljs-string">"CustomSerializer"</span>,
                <span class="hljs-attr">"typeId"</span>: <span class="hljs-number">10</span>
            }
        ]
    }
}
</code></pre>
				<p>From now on, Hazelcast will use <code>CustomSerializer</code> to serialize <code>CustomSerializable</code> objects.</p>
				<h2 id="4-4-global-serialization">4.4. Global Serialization</h2>
				<p>The global serializer is identical to custom serializers from the implementation perspective. The global serializer is registered as a fallback serializer to handle all other objects if a serializer cannot be located for them.</p>
				<p>By default, JSON serialization is used if the object is not <code>IdentifiedDataSerializable</code> or <code>Portable</code> or there is no custom serializer for it. When you configure a global serializer, it is used instead of JSON serialization.</p>
				<p><strong>Use cases:</strong></p>
				<ul>
					<li>Third party serialization frameworks can be integrated using the global serializer.</li>
					<li>For your custom objects, you can implement a single serializer to handle all of them.</li>
				</ul>
				<p>A sample global serializer that integrates with a third party serializer is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GlobalSerializer</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Constructor function</span>
}

GlobalSerializer.prototype.getId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>;
};

GlobalSerializer.prototype.read = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">input</span>) </span>{
    <span class="hljs-keyword">return</span> MyFavoriteSerializer.deserialize(input.readByteArray());
};

GlobalSerializer.prototype.write = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">output, obj</span>) </span>{
    output.writeByteArray(MyFavoriteSerializer.serialize(obj))
};
</code></pre>
				<p>You should register the global serializer in the configuration.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript">config.serializationConfig.globalSerializer = <span class="hljs-keyword">new</span> GlobalSerializer();
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"serialization"</span>: {
        <span class="hljs-attr">"defaultNumberType"</span>: <span class="hljs-string">"integer"</span>,
        <span class="hljs-attr">"isBigEndian"</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">"globalSerializer"</span>: {
            <span class="hljs-attr">"path"</span>: <span class="hljs-string">"global_serializer.js"</span>,
            <span class="hljs-attr">"exportedName"</span>: <span class="hljs-string">"MyFavoriteSerializer"</span>
        }
    }
}
</code></pre>
				<h2 id="4-5-json-serialization">4.5. JSON Serialization</h2>
				<p>If the Hazelcast Node.js client cannot find a suitable serializer for an object, it uses <code>JSON Serialization</code> by default. With <code>JSON Serialization</code>, objects
				are converted to JSON strings and transmitted to the Hazelcast members as such. </p>
				<p>When the Hazelcast Node.js client retrieves a JSON serialized data from a member, it parses the JSON string and returns the object represented by that
				string to the user. However, you may want to defer the string parsing and work with the raw JSON strings.</p>
				<p>For this purpose, you can configure your client to return <code>HazelcastJsonValue</code> objects when it retrieves a JSON serialized data from a member.</p>
				<p><code>HazelcastJsonValue</code> is a lightweight wrapper around the JSON strings. You may get the JSON string representation of the object using the <code>toString</code> method.  </p>
				<p>Below is the configuration required to return <code>HazelcastJsonValue</code> objects instead of JavaScript objects.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript">config.serializationConfig.jsonStringDeserializationPolicy = JsonStringDeserializationPolicy.NO_DESERIALIZATION;
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"serialization"</span>: {
        <span class="hljs-attr">"jsonStringDeserializationPolicy"</span>: <span class="hljs-string">"no_deserialization"</span>
    }
}
</code></pre>
				<h2 id="4-6-string-serialization">4.6. String Serialization</h2>
				<p>Starting from version v3.12 Hazelcast Node.js client follows UTF-8 standard (RFC 3629) for string data type serialization of 4 byte UTF characters, like less common CJK characters and emoji. This may lead to compatibility issues with Hazelcast IMDG 3.x and other client libraries for string and JSON values. Such issues are represented by <code>Malformed byte sequence</code> (error code 64) errors on members and other clients.</p>
				<p>In case if you encounter these error messages, you can switch to the legacy mode of string serialization that provides full compatibility with Hazelcast IMDG 3.x members and other client libraries.</p>
				<p>Below is the configuration required to use the legacy string serialization.</p>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript">config.serializationConfig.stringSerializationPolicy = StringSerializationPolicy.LEGACY;
</code></pre>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"serialization"</span>: {
        <span class="hljs-attr">"stringSerializationPolicy"</span>: <span class="hljs-string">"legacy"</span>
    }
}
</code></pre>
				<h1 id="5-setting-up-client-network">5. Setting Up Client Network</h1>
				<p>All network related configuration of Hazelcast Node.js client is performed via the <code>network</code> element in the declarative configuration file, or in the object <code>ClientNetworkConfig</code> when using programmatic configuration. Let&#39;s first give the examples for these two approaches. Then we will look at its sub-elements and attributes.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<p>Here is an example of configuring the network for Node.js Client declaratively.</p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"clusterMembers"</span>: [
            <span class="hljs-string">"10.1.1.21"</span>,
            <span class="hljs-string">"10.1.1.22:5703"</span>
        ],
        <span class="hljs-attr">"smartRouting"</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">"redoOperation"</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">"connectionTimeout"</span>: <span class="hljs-number">6000</span>,
        <span class="hljs-attr">"connectionAttemptPeriod"</span>: <span class="hljs-number">5000</span>,
        <span class="hljs-attr">"connectionAttemptLimit"</span>: <span class="hljs-number">5</span>
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<p>Here is an example of configuring the network for Node.js Client programmatically.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.networkConfig.addresses.push(<span class="hljs-string">'10.1.1.21'</span>, <span class="hljs-string">'10.1.1.22:5703'</span>);
clientConfig.networkConfig.smartRouting = <span class="hljs-literal">true</span>;
clientConfig.networkConfig.redoOperation = <span class="hljs-literal">true</span>;
clientConfig.networkConfig.connectionTimeout = <span class="hljs-number">6000</span>;
clientConfig.networkConfig.connectionAttemptPeriod = <span class="hljs-number">5000</span>;
clientConfig.networkConfig.connectionAttemptLimit = <span class="hljs-number">5</span>;
</code></pre>
				<h2 id="5-1-providing-member-addresses">5.1. Providing Member Addresses</h2>
				<p>Address list is the initial list of cluster addresses which the client will connect to. The client uses this
					list to find an alive member. Although it may be enough to give only one address of a member in the cluster
				(since all members communicate with each other), it is recommended that you give the addresses for all the members.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"clusterMembers"</span>: [
            <span class="hljs-string">"10.1.1.21"</span>,
            <span class="hljs-string">"10.1.1.22:5703"</span>
        ]
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.networkConfig.addresses.push(<span class="hljs-string">'10.1.1.21'</span>, <span class="hljs-string">'10.1.1.22:5703'</span>);
</code></pre>
				<p>If the port part is omitted, then 5701, 5702 and 5703 will be tried in a random order.</p>
				<p>You can specify multiple addresses with or without the port information as seen above. The provided list is shuffled and tried in a random order. Its default value is <code>localhost</code>.</p>
				<h2 id="5-2-setting-smart-routing">5.2. Setting Smart Routing</h2>
				<p>Smart routing defines whether the client mode is smart or unisocket. See the <a href="#72-nodejs-client-operation-modes">Node.js Client Operation Modes section</a>
				for the description of smart and unisocket modes.</p>
				<p>The following are example configurations.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"smartRouting"</span>: <span class="hljs-literal">true</span>
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.networkConfig.smartRouting = <span class="hljs-literal">true</span>;
</code></pre>
				<p>Its default value is <code>true</code> (smart client mode).</p>
				<h2 id="5-3-enabling-redo-operation">5.3. Enabling Redo Operation</h2>
				<p>It enables/disables redo-able operations. While sending the requests to the related members, the operations can fail due to various reasons. Read-only operations are retried by default. If you want to enable retry for the other operations, you can set the <code>redoOperation</code> to <code>true</code>.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"redoOperation"</span>: <span class="hljs-literal">true</span>
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.networkConfig.redoOperation = <span class="hljs-literal">true</span>;
</code></pre>
				<p>Its default value is <code>false</code> (disabled).</p>
				<h2 id="5-4-setting-connection-timeout">5.4. Setting Connection Timeout</h2>
				<p>Connection timeout is the timeout value in milliseconds for the members to accept the client connection requests.
				If the member does not respond within the timeout, the client will retry to connect as many as <code>ClientNetworkConfig.connectionAttemptLimit</code> times.</p>
				<p>The following are the example configurations.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"connectionTimeout"</span>: <span class="hljs-number">6000</span>
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.networkConfig.connectionTimeout = <span class="hljs-number">6000</span>;
</code></pre>
				<p>Its default value is <code>5000</code> milliseconds.</p>
				<h2 id="5-5-setting-connection-attempt-limit">5.5. Setting Connection Attempt Limit</h2>
				<p>While the client is trying to connect initially to one of the members in the <code>ClientNetworkConfig.addresses</code>, that member might not be available at that moment. Instead of giving up, throwing an error and stopping the client, the client will retry as many as <code>ClientNetworkConfig.connectionAttemptLimit</code> times. This is also the case when the previously established connection between the client and that member goes down.</p>
				<p>The following are example configurations.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"connectionAttemptLimit"</span>: <span class="hljs-number">5</span>
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.networkConfig.connectionAttemptLimit = <span class="hljs-number">5</span>;
</code></pre>
				<p>Its default value is <code>2</code>.</p>
				<h2 id="5-6-setting-connection-attempt-period">5.6. Setting Connection Attempt Period</h2>
				<p>Connection attempt period is the duration in milliseconds between the connection attempts defined by <code>ClientNetworkConfig.connectionAttemptLimit</code>.</p>
				<p>The following are example configurations.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"connectionAttemptPeriod"</span>: <span class="hljs-number">5000</span>
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.networkConfig.connectionAttemptPeriod = <span class="hljs-number">5000</span>;
</code></pre>
				<p>Its default value is <code>3000</code> milliseconds.</p>
				<h2 id="5-7-enabling-client-tls-ssl">5.7. Enabling Client TLS/SSL</h2>
				<p>You can use TLS/SSL to secure the connection between the clients and members. If you want to enable TLS/SSL
				for the client-cluster connection, you should set an SSL configuration. Please see <a href="#61-tlsssl">TLS/SSL section</a>.</p>
				<p>As explained in the <a href="#61-tlsssl">TLS/SSL section</a>, Hazelcast members have key stores used to identify themselves (to other members) and Hazelcast Node.js clients have certificate authorities used to define which members they can trust. Hazelcast has the mutual authentication feature which allows the Node.js clients also to have their private keys and public certificates, and members to have their certificate authorities so that the members can know which clients they can trust. See the <a href="#613-mutual-authentication">Mutual Authentication section</a>.</p>
				<h2 id="5-8-enabling-hazelcast-cloud-discovery">5.8. Enabling Hazelcast Cloud Discovery</h2>
				<p>The purpose of Hazelcast Cloud Discovery is to provide the clients to use IP addresses provided by <code>hazelcast orchestrator</code>. To enable Hazelcast Cloud Discovery, specify a token for the <code>discoveryToken</code> field and set the <code>enabled</code> field to <code>true</code>.</p>
				<p>The following are example configurations.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
 <span class="hljs-attr">"group"</span>: {
        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"hazel"</span>,
        <span class="hljs-attr">"password"</span>: <span class="hljs-string">"cast"</span>
    },

    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"hazelcastCloud"</span>: {
            <span class="hljs-attr">"discoveryToken"</span>: <span class="hljs-string">"EXAMPLE_TOKEN"</span>,
            <span class="hljs-attr">"enabled"</span>: <span class="hljs-literal">true</span>
        }
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.groupConfig.name = <span class="hljs-string">'hazel'</span>;
clientConfig.groupConfig.password = <span class="hljs-string">'cast'</span>;

clientConfig.networkConfig.cloudConfig.enabled = <span class="hljs-literal">true</span>;
clientConfig.networkConfig.cloudConfig.discoveryToken = <span class="hljs-string">'EXAMPLE_TOKEN'</span>;
</code></pre>
				<p>To be able to connect to the provided IP addresses, you should use secure TLS/SSL connection between the client and members. Therefore, you should set an SSL configuration as described in the previous section.</p>
				<h1 id="6-securing-client-connection">6. Securing Client Connection</h1>
				<p>This chapter describes the security features of Hazelcast Node.js client. These include using TLS/SSL for connections between members and between clients and members, mutual authentication and credentials. These security features require <strong>Hazelcast IMDG Enterprise</strong> edition.</p>
				<h3 id="6-1-tls-ssl">6.1. TLS/SSL</h3>
				<p>One of the offers of Hazelcast is the TLS/SSL protocol which you can use to establish an encrypted communication across your cluster with key stores and trust stores.</p>
				<ul>
					<li>A Java <code>keyStore</code> is a file that includes a private key and a public certificate. The equivalent of a key store is the combination of <code>key</code> and <code>cert</code> files at the Node.js client side.</li>
					<li>A Java <code>trustStore</code> is a file that includes a list of certificates trusted by your application which is named as  &quot;certificate authority&quot;. The equivalent of a trust store is a <code>ca</code> file at the Node.js client side.</li>
				</ul>
				<p>You should set <code>keyStore</code> and <code>trustStore</code> before starting the members. See the next section on setting <code>keyStore</code> and <code>trustStore</code> on the server side.</p>
				<h4 id="6-1-1-tls-ssl-for-hazelcast-members">6.1.1. TLS/SSL for Hazelcast Members</h4>
				<p>Hazelcast allows you to encrypt socket level communication between Hazelcast members and between Hazelcast clients and members, for end to end encryption. To use it, see the <a href="http://docs.hazelcast.org/docs/latest/manual/html-single/index.html#tls-ssl-for-hazelcast-members">TLS/SSL for Hazelcast Members section</a>.</p>
				<h4 id="6-1-2-tls-ssl-for-hazelcast-node-js-clients">6.1.2. TLS/SSL for Hazelcast Node.js Clients</h4>
				<p>TLS/SSL for the Hazelcast Node.js client can be configured using the <code>SSLConfig</code> class. In order to turn it on, <code>enabled</code> property of <code>SSLConfig</code> should be set to <code>true</code>:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
<span class="hljs-keyword">var</span> sslConfig = <span class="hljs-keyword">new</span> Config.SSLConfig();
sslConfig.enabled = <span class="hljs-literal">true</span>;
clientConfig.networkConfig.sslConfig = sslConfig;
</code></pre>
				<p><code>SSLConfig</code> object takes various SSL options defined in the <a href="https://nodejs.org/api/tls.html#tls_tls_connect_options_callback">Node.js TLS Documentation</a>. You can set your custom options
				object to <code>sslConfig.sslOptions</code>.</p>
				<h4 id="6-1-3-mutual-authentication">6.1.3. Mutual Authentication</h4>
				<p>As explained above, Hazelcast members have key stores used to identify themselves (to other members) and Hazelcast clients have trust stores used to define which members they can trust.</p>
				<p>Using mutual authentication, the clients also have their key stores and members have their trust stores so that the members can know which clients they can trust.</p>
				<p>To enable mutual authentication, firstly, you need to set the following property on the server side in the <code>hazelcast.xml</code> file:</p>
				<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">network</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ssl</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"true"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"javax.net.ssl.mutualAuthentication"</span>&gt;</span>REQUIRED<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ssl</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">network</span>&gt;</span>
</code></pre>
				<p>You can see the details of setting mutual authentication on the server side in the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#mutual-authentication">Mutual Authentication section</a> of the Hazelcast IMDG Reference Manual.</p>
				<p>At the Node.js client side, you need to supply an SSL <code>options</code> object to pass to
				<a href="https://nodejs.org/api/tls.html#tls_tls_connect_options_callback"><code>tls.connect</code></a> of Node.js.</p>
				<p>There are two ways to provide this object to the client:</p>
				<ol>
					<li>Using the built-in <code>BasicSSLOptionsFactory</code> bundled with the client.</li>
					<li>Writing an <code>SSLOptionsFactory</code>.</li>
				</ol>
				<p>Below subsections describe each way.</p>
				<p><strong>Using the Built-in <code>BasicSSLOptionsFactory</code></strong></p>
				<p>Hazelcast Node.js client includes a utility factory class that creates the necessary <code>options</code> object out of the supplied
				properties. All you need to do is to specify your factory as <code>BasicSSLOptionsFactory</code> and provide the following options:</p>
				<ul>
					<li><code>caPath</code></li>
					<li><code>keyPath</code></li>
					<li><code>certPath</code></li>
					<li><code>servername</code></li>
					<li><code>rejectUnauthorized</code></li>
					<li><code>ciphers</code></li>
				</ul>
				<p>See <a href="https://nodejs.org/api/tls.html#tls_tls_connect_options_callback"><code>tls.connect</code></a> of Node.js for the descriptions of each option.</p>
				<blockquote>
					<p><code>caPath</code>, <code>keyPath</code> and <code>certPath</code> define the file path to the respective file that stores such information.</p>
				</blockquote>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"ssl"</span>: {
            <span class="hljs-attr">"enabled"</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">"factory"</span>: {
                <span class="hljs-attr">"exportedName"</span>: <span class="hljs-string">"BasicSSLOptionsFactory"</span>,
                <span class="hljs-attr">"properties"</span>: {
                    <span class="hljs-attr">"caPath"</span>: <span class="hljs-string">"ca.pem"</span>,
                    <span class="hljs-attr">"keyPath"</span>: <span class="hljs-string">"key.pem"</span>,
                    <span class="hljs-attr">"certPath"</span>: <span class="hljs-string">"cert.pem"</span>,
                    <span class="hljs-attr">"rejectUnauthorized"</span>: <span class="hljs-literal">false</span>
                }
            }
        }
    }
}
</code></pre>
				<p>If these options are not enough for your application, you may write your own options factory and instruct the client
				to get the options from it, as explained below.</p>
				<p><strong>Writing an <code>SSLOptionsFactory</code></strong></p>
				<p>In order to use the full range of options provided to <a href="https://nodejs.org/api/tls.html#tls_tls_connect_options_callback"><code>tls.connect</code></a> of Node.js, you may write your own factory object.</p>
				<p>An example configuration is shown below.</p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"network"</span>: {
        <span class="hljs-attr">"ssl"</span>: {
            <span class="hljs-attr">"enabled"</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">"factory"</span>: {
                <span class="hljs-attr">"path"</span>: <span class="hljs-string">"my_factory.js"</span>,
                <span class="hljs-attr">"exportedName"</span>: <span class="hljs-string">"SSLFactory"</span>,
                <span class="hljs-attr">"properties"</span>: {
                    <span class="hljs-attr">"caPath"</span>: <span class="hljs-string">"ca.pem"</span>,
                    <span class="hljs-attr">"keyPath"</span>: <span class="hljs-string">"key.pem"</span>,
                    <span class="hljs-attr">"certPath"</span>: <span class="hljs-string">"cert.pem"</span>,
                    <span class="hljs-attr">"keepOrder"</span>: <span class="hljs-literal">true</span>
                }
            }
        }
    }
}
</code></pre>
				<p>An example of a factory, <code>my_factory.js</code>, is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SSLFactory</span>(<span class="hljs-params"></span>) </span>{
}

SSLFactory.prototype.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">this</span>.caPath = props.caPath;
    <span class="hljs-keyword">this</span>.keyPath = props.keyPath;
    <span class="hljs-keyword">this</span>.certPath = props.certPath;
    <span class="hljs-keyword">this</span>.keepOrder = props.userDefinedProperty1;
};

SSLFactory.prototype.getSSLOptions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> sslOpts = {
        <span class="hljs-attr">servername</span>: <span class="hljs-string">'foo.bar.com'</span>,
        <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">ca</span>: fs.readFileSync(<span class="hljs-keyword">this</span>.caPath)
        key: fs.readFileSync(<span class="hljs-keyword">this</span>.keyPath),
        <span class="hljs-attr">cert</span>: fs.readFileSync(<span class="hljs-keyword">this</span>.certPath),
    };
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.keepOrder) {
        sslOpts.honorCipherOrder = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> sslOpts;
};
exports.SSLFactory = SSLFactory;
</code></pre>
				<p>The client loads <code>MyFactory.js</code> at runtime and creates an instance of <code>SSLFactory</code>. It then calls the method <code>init</code> with
				the properties section in the JSON configuration file. Lastly, the client calls the method <code>getSSLOptions</code> of <code>SSLFactory</code> to create the <code>options</code> object.</p>
				<p>For information about the path resolution, see the <a href="#33-loading-objects-and-path-resolution">Loading Objects and Path Resolution section</a>.</p>
				<h2 id="6-2-credentials">6.2. Credentials</h2>
				<p>One of the key elements in Hazelcast security is the <code>Credentials</code> object, which can be used to carry all security attributes of the
					Hazelcast Node.js client to Hazelcast members. Then, Hazelcast members can authenticate the clients and perform access control
				checks on the client operations using this <code>Credentials</code> object.</p>
				<p>To use this feature, you need to </p>
				<ul>
					<li>have a class implementing the <a href="https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/security/Credentials.html"><code>Credentials</code></a> interface which contains the security attributes of your client</li>
					<li>have a class implementing the <a href="https://docs.oracle.com/javase/6/docs/api/javax/security/auth/spi/LoginModule.html?is-external=true"><code>LoginModule</code></a> interface which uses the <code>Credentials</code> object during the authentication process</li>
					<li>configure your Hazelcast member&#39;s security properties with respect to these classes before starting it. If you have started your member as described in the <a href="#1211-running-standalone-jars">Running Standalone JARs section</a>, see the <a href="#1212-adding-user-library-to-classpath">Adding User Library to CLASSPATH section</a>.</li>
				</ul>
				<p><a href="https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/security/UsernamePasswordCredentials.html"><code>UsernamePasswordCredentials</code></a>, a basic implementation of the <code>Credentials</code> interface, is available in the Hazelcast <code>com.hazelcast.security</code> package.
				<code>UsernamePasswordCredentials</code> is used for default configuration during the authentication process of both members and clients. You can also use this class to carry the security attributes of your client.</p>
				<p>Hazelcast also has an abstract implementation of the <code>LoginModule</code> interface which is the <code>ClusterLoginModule</code> class in the <code>com.hazelcast.security</code> package.
				You can extend this class and do the authentication on the <code>onLogin()</code> method. </p>
				<p>Below is an example for the extension of abstract <code>ClusterLoginModule</code> class.
				On the <code>ClientLoginModule#onLogin()</code> method, we are doing a simple authentication against a hardcoded username and password just for illustrative purposes. You should carry out the authentication against a security service of your choice.</p>
				<pre><code class="lang-java"><span class="hljs-keyword">import</span> com.hazelcast.security.ClusterLoginModule;
<span class="hljs-keyword">import</span> com.hazelcast.security.UsernamePasswordCredentials;

<span class="hljs-keyword">import</span> javax.security.auth.login.FailedLoginException;
<span class="hljs-keyword">import</span> javax.security.auth.login.LoginException;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientLoginModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClusterLoginModule</span> </span>{

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLogin</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> LoginException </span>{
      <span class="hljs-keyword">if</span> (credentials <span class="hljs-keyword">instanceof</span> UsernamePasswordCredentials) {
          UsernamePasswordCredentials usernamePasswordCredentials = (UsernamePasswordCredentials) credentials;
          String username = usernamePasswordCredentials.getUsername();
          String password = usernamePasswordCredentials.getPassword();

          <span class="hljs-keyword">if</span> (username.equals(<span class="hljs-string">"admin"</span>) &amp;&amp; password.equals(<span class="hljs-string">"password"</span>)) {
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
          }
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> FailedLoginException(<span class="hljs-string">"Username or password doesn't match expected value."</span>);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onCommit</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> loginSucceeded;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onAbort</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLogout</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
  }
}
</code></pre>
				<p>Finally, you can configure <code>hazelcast.xml</code> as follows to enable Hazelcast security, do mandatory authentication with <code>ClientLoginModule</code>
				and give the user with the name <code>admin</code> all the permissions over the map named <code>importantMap</code>.</p>
				<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hazelcast</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">security</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"true"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">client-login-modules</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">login-module</span> <span class="hljs-attr">class-name</span>=<span class="hljs-string">"com.company.ClientLoginModule"</span> <span class="hljs-attr">usage</span>=<span class="hljs-string">"REQUIRED"</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">client-login-modules</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">client-permissions</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">map-permission</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"importantMap"</span> <span class="hljs-attr">principal</span>=<span class="hljs-string">"admin"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">actions</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">action</span>&gt;</span>all<span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">actions</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">map-permission</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">client-permissions</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">security</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hazelcast</span>&gt;</span>
</code></pre>
				<p>After successfully starting a Hazelcast member as described above, you need to implement <code>Portable</code> equivalent of the <code>UsernamePasswordCredentials</code>
				and register it to your client configuration.</p>
				<p>Below is the code for that.</p>
				<p><strong>user_pass_cred.js</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UsernamePasswordCredentials</span>(<span class="hljs-params">username, password, endpoint</span>) </span>{
    <span class="hljs-keyword">this</span>.username = username;
    <span class="hljs-keyword">this</span>.password = Buffer.from(password, <span class="hljs-string">'utf8'</span>);
    <span class="hljs-keyword">this</span>.endpoint = endpoint;
}

UsernamePasswordCredentials.prototype.readPortable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reader</span>) </span>{
    <span class="hljs-keyword">this</span>.username = reader.readUTF(<span class="hljs-string">'principal'</span>);
    <span class="hljs-keyword">this</span>.endpoint = reader.readUTF(<span class="hljs-string">'endpoint'</span>);
    <span class="hljs-keyword">this</span>.password = reader.readByteArray(<span class="hljs-string">'pwd'</span>);
};

UsernamePasswordCredentials.prototype.writePortable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">writer</span>) </span>{
    writer.writeUTF(<span class="hljs-string">'principal'</span>, <span class="hljs-keyword">this</span>.username);
    writer.writeUTF(<span class="hljs-string">'endpoint'</span>, <span class="hljs-keyword">this</span>.endpoint);
    writer.writeByteArray(<span class="hljs-string">'pwd'</span>, <span class="hljs-keyword">this</span>.password);
};

UsernamePasswordCredentials.prototype.getFactoryId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
};

UsernamePasswordCredentials.prototype.getClassId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
};

exports.UsernamePasswordCredentials = UsernamePasswordCredentials;
</code></pre>
				<p>And below is the <code>Factory</code> implementation for the <code>Portable</code> implementation of <code>UsernamePasswordCredentials</code>.</p>
				<p><strong>user_pass_cred_factory.js</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> UsernamePasswordCredentials = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./user_pass_cred'</span>).UsernamePasswordCredentials;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UsernamePasswordCredentialsFactory</span>(<span class="hljs-params"></span>) </span>{
}

UsernamePasswordCredentialsFactory.prototype.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">classId</span>) </span>{
    <span class="hljs-keyword">if</span>(classId === <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UsernamePasswordCredentials();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};

exports.UsernamePasswordCredentialsFactory = UsernamePasswordCredentialsFactory;
</code></pre>
				<p>Now, you can start your client by registering the <code>Portable</code> factory and giving the credentials as follows.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Client = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Client;
<span class="hljs-keyword">var</span> ClientConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'hazelcast-client'</span>).Config.ClientConfig;

<span class="hljs-keyword">var</span> UsernamePasswordCredentials = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./user_pass_cred'</span>).UsernamePasswordCredentials;
<span class="hljs-keyword">var</span> UsernamePasswordCredentialsFactory = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./user_pass_cred_factory'</span>).UsernamePasswordCredentialsFactory;

<span class="hljs-keyword">var</span> config = <span class="hljs-keyword">new</span> ClientConfig();
config.serializationConfig.portableVersion = <span class="hljs-number">1</span>;
config.serializationConfig.portableFactories[<span class="hljs-number">-1</span>] = <span class="hljs-keyword">new</span> UsernamePasswordCredentialsFactory();
config.customCredentials = <span class="hljs-keyword">new</span> UsernamePasswordCredentials(<span class="hljs-string">'admin'</span>, <span class="hljs-string">'password'</span>, <span class="hljs-string">'127.0.0.1'</span>);

Client.newHazelcastClient(config).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>{
    <span class="hljs-keyword">var</span> map;
    <span class="hljs-keyword">return</span> client.getMap(<span class="hljs-string">'importantMap'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
        map = mp;
        <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> map.get(<span class="hljs-string">'key'</span>);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-built_in">console</span>.log(value);
        <span class="hljs-keyword">return</span> client.shutdown();
    });
});
</code></pre>
				<blockquote>
					<p>NOTE: It is almost always a bad idea to write the credentials to wire in a clear-text format. Therefore, using TLS/SSL encryption is highly recommended while using the custom credentials as described in <a href="(#61-tlsssl">TLS/SSL section</a>).</p>
				</blockquote>
				<p>With Hazelcast&#39;s extensible, <code>JAAS</code> based security features you can do much more than just authentication.
				See the <a href="code_samples/jaas_sample">JAAS code sample</a> to learn how to perform access control checks on the client operations based on user groups.</p>
				<p>Also, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#security">Security section</a> of Hazelcast IMDG Reference Manual for more information.</p>
				<h1 id="7-using-node-js-client-with-hazelcast-imdg">7. Using Node.js Client with Hazelcast IMDG</h1>
				<p>This chapter provides information on how you can use Hazelcast IMDG&#39;s data structures in the Node.js client, after giving some basic information including an overview to the client API, operation modes of the client and how it handles the failures.</p>
				<h2 id="7-1-node-js-client-api-overview">7.1. Node.js Client API Overview</h2>
				<p>Most of the functions in the API return <code>Promise</code>. Therefore, you need to be familiar with the concept of promises to use the Node.js client. If not, you can learn about them using various online resources, e.g., the <a href="https://www.promisejs.org/">Promise JS</a> website.</p>
				<p>Promises provide a better way of working with callbacks. You can chain asynchronous functions by the <code>then()</code> function of promise. Also, you can use <code>async/await</code>, if you use Node.js 8 and higher versions.</p>
				<p>If you are ready to go, let&#39;s start to use Hazelcast Node.js client.</p>
				<p>The first step is the configuration. You can configure the Node.js client declaratively or programmatically. We will use the programmatic approach throughout this chapter. See the <a href="#311-programmatic-configuration">Programmatic Configuration section</a> for details.</p>
				<p>The following is an example on how to create a <code>ClientConfig</code> object and configure it programmatically:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.groupConfig.name = <span class="hljs-string">'dev'</span>;
clientConfig.networkConfig.addresses.push(<span class="hljs-string">'10.90.0.1'</span>, <span class="hljs-string">'10.90.0.2:5702'</span>);
</code></pre>
				<p>The second step is initializing the <code>HazelcastClient</code> to be connected to the cluster:</p>
				<pre><code class="lang-javascript">Client.newHazelcastClient(clientConfig).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>{
    <span class="hljs-comment">// some operation</span>
});
</code></pre>
				<p><strong>This client object is your gateway to access all the Hazelcast distributed objects.</strong></p>
				<p>Let&#39;s create a map and populate it with some data, as shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map;
<span class="hljs-comment">// Get the Distributed Map from Cluster.</span>
client.getMap(<span class="hljs-string">'my-distributed-map'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    map = mp;
    <span class="hljs-comment">// Standard Put and Get.</span>
    <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.get(<span class="hljs-string">'key'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{
    <span class="hljs-comment">// Concurrent Map methods, optimistic updating</span>
    <span class="hljs-keyword">return</span> map.putIfAbsent(<span class="hljs-string">'somekey'</span>, <span class="hljs-string">'somevalue'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.replace(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>, <span class="hljs-string">'newvalue'</span>);
});
</code></pre>
				<p>As the final step, if you are done with your client, you can shut it down as shown below. This will release all the used resources and close connections to the cluster.</p>
				<pre><code class="lang-javascript">...
.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    client.shutdown();
});
</code></pre>
				<h2 id="7-2-node-js-client-operation-modes">7.2. Node.js Client Operation Modes</h2>
				<p>The client has two operation modes because of the distributed nature of the data and cluster: smart and unisocket.</p>
				<h3 id="7-2-1-smart-client">7.2.1. Smart Client</h3>
				<p>In the smart mode, the clients connect to each cluster member. Since each data partition uses the well known and consistent hashing algorithm, each client can send an operation to the relevant cluster member, which increases the overall throughput and efficiency. Smart mode is the default mode.</p>
				<h3 id="7-2-2-unisocket-client">7.2.2. Unisocket Client</h3>
				<p>For some cases, the clients can be required to connect to a single member instead of each member in the cluster. Firewalls, security or some custom networking issues can be the reason for these cases.</p>
				<p>In the unisocket client mode, the client will only connect to one of the configured addresses. This single member will behave as a gateway to the other members. For any operation requested from the client, it will redirect the request to the relevant member and return the response back to the client returned from this member.</p>
				<h2 id="7-3-handling-failures">7.3. Handling Failures</h2>
				<p>There are two main failure cases you should be aware of. Below sections explain these and the configurations you can perform to achieve proper behavior.</p>
				<h3 id="7-3-1-handling-client-connection-failure">7.3.1. Handling Client Connection Failure</h3>
				<p>While the client is trying to connect initially to one of the members in the <code>ClientNetworkConfig.addressList</code>, all the members might not be available. Instead of giving up, throwing an error and stopping the client, the client will retry as many as <code>connectionAttemptLimit</code> times.</p>
				<p>You can configure <code>connectionAttemptLimit</code> for the number of times you want the client to retry connecting. See the <a href="#55-setting-connection-attempt-limit">Setting Connection Attempt Limit section</a>.</p>
				<p>The client executes each operation through the already established connection to the cluster. If this connection(s) disconnects or drops, the client will try to reconnect as configured.</p>
				<h3 id="7-3-2-handling-retry-able-operation-failure">7.3.2. Handling Retry-able Operation Failure</h3>
				<p>While sending the requests to the related members, the operations can fail due to various reasons. Read-only operations are retried by default. If you want to enable retrying for the other operations, you can set the <code>redoOperation</code> to <code>true</code>. See the <a href="#53-enabling-redo-operation">Enabling Redo Operation section</a>.</p>
				<p>You can set a timeout for retrying the operations sent to a member. This can be provided by using the property <code>hazelcast.client.invocation.timeout.seconds</code> in <code>ClientConfig.properties</code>. The client will retry an operation within this given period, of course, if it is a read-only operation or you enabled the <code>redoOperation</code> as stated in the above paragraph. This timeout value is important when there is a failure resulted by either of the following causes:</p>
				<ul>
					<li>Member throws an exception.</li>
					<li>Connection between the client and member is closed.</li>
					<li>Client’s heartbeat requests are timed out.</li>
				</ul>
				<p>When a connection problem occurs, an operation is retried if it is certain that it has not run on the member yet or if it is idempotent such as a read-only operation, i.e., retrying does not have a side effect. If it is not certain whether the operation has run on the member, then the non-idempotent operations are not retried. However, as explained in the first paragraph of this section, you can force all the client operations to be retried (<code>redoOperation</code>) when there is a connection failure between the client and member. But in this case, you should know that some operations may run multiple times causing conflicts. For example, assume that your client sent a <code>queue.offer</code> operation to the member and then the connection is lost. Since there will be no response for this operation, you will not know whether it has run on the member or not. If you enabled <code>redoOperation</code>, it means this operation may run again, which may cause two instances of the same object in the queue.</p>
				<h2 id="7-4-using-distributed-data-structures">7.4. Using Distributed Data Structures</h2>
				<p>Most of the distributed data structures are supported by the Node.js client. In this chapter, you will learn how to use these distributed data structures.</p>
				<h3 id="7-4-1-using-map">7.4.1. Using Map</h3>
				<p>Hazelcast Map (<code>IMap</code>) is a distributed map. Through the Node.js client, you can perform operations like reading and writing from/to a Hazelcast Map with the well known get and put methods. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#map">Map section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Map usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map;
<span class="hljs-comment">// Get the Distributed Map from Cluster.</span>
hz.getMap(<span class="hljs-string">'my-distributed-map'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    map = mp;
    <span class="hljs-comment">// Standard Put and Get.</span>
    <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.get(<span class="hljs-string">'key'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>{
    <span class="hljs-comment">// Concurrent Map methods, optimistic updating</span>
    <span class="hljs-keyword">return</span> map.putIfAbsent(<span class="hljs-string">'somekey'</span>, <span class="hljs-string">'somevalue'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.replace(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>, <span class="hljs-string">'newvalue'</span>);
});
</code></pre>
				<p>Hazelcast Map supports a Near Cache for remotely stored entries to increase the performance of read operations. See the <a href="#782-near-cache">Near Cache section</a> for a detailed explanation of the Near Cache feature and its configuration.</p>
				<p>Hazelcast Map uses <code>MapListener</code> to listen to the events that occur when the entries are added to, updated/merged in or evicted/removed from the Map. See the <a href="#7521-map-listener">Map Listener section</a> for information on how to create a map listener object and register it.</p>
				<h3 id="7-4-2-using-multimap">7.4.2. Using MultiMap</h3>
				<p>Hazelcast <code>MultiMap</code> is a distributed and specialized map where you can store multiple values under a single key. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#multimap">MultiMap section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A MultiMap usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> multiMap;
<span class="hljs-comment">// Get the Distributed MultiMap from Cluster.</span>
hz.getMultiMap(<span class="hljs-string">'my-distributed-multimap'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mmp</span>) </span>{
    multiMap = mmp;
    <span class="hljs-comment">// Put values in the map against the same key</span>
    <span class="hljs-keyword">return</span> multiMap.put(<span class="hljs-string">'my-key'</span>, <span class="hljs-string">'value1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> multiMap.put(<span class="hljs-string">'my-key'</span>, <span class="hljs-string">'value2'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> multiMap.put(<span class="hljs-string">'my-key'</span>, <span class="hljs-string">'value3'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Print out all the values for associated with key called "my-key"</span>
    <span class="hljs-keyword">return</span> multiMap.get(<span class="hljs-string">'my-key'</span>)
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>{
    <span class="hljs-keyword">for</span> (value <span class="hljs-keyword">of</span> values) {
        <span class="hljs-built_in">console</span>.log(value);
    }
    <span class="hljs-comment">// remove specific key/value pair</span>
    <span class="hljs-keyword">return</span> multiMap.remove(<span class="hljs-string">'my-key'</span>, <span class="hljs-string">'value2'</span>);
});
</code></pre>
				<p>Hazelcast MultiMap uses <code>EntryListener</code> to listen to the events that occur when the entries are added to or removed from the MultiMap. See the <a href="#7522-entry-listener">Entry Listener section</a> for information on how to create an entry listener object and register it.</p>
				<h3 id="7-4-3-using-replicated-map">7.4.3. Using Replicated Map</h3>
				<p>Hazelcast <code>ReplicatedMap</code> is a distributed key-value data structure where the data is replicated to all members in the cluster. It provides full replication of entries to all members for high speed access. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#replicated-map">Replicated Map section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Replicated Map usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map;
<span class="hljs-comment">// Get a Replicated Map called "my-replicated-map"</span>
hz.getReplicatedMap(<span class="hljs-string">'my-replicated-map'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">rmp</span>) </span>{
    map = rmp;
    <span class="hljs-comment">// Put and Get a value from the Replicated Map</span>
    <span class="hljs-comment">// key/value replicated to all members</span>
    <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'key'</span>, <span class="hljs-string">'value'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">replacedValue</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'replaced value = '</span> + replacedValue); <span class="hljs-comment">// Will be null as its first update</span>
    <span class="hljs-keyword">return</span> map.get(<span class="hljs-string">'key'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-comment">// The value is retrieved from a random member in the cluster</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'value for key = '</span> + value);
});
</code></pre>
				<p>Hazelcast Replicated Map uses <code>EntryListener</code> to listen to the events that occur when the entries are added to, updated in or evicted/removed from the Replicated Map. See the <a href="#7522-entry-listener">Entry Listener section</a> for information on how to create an entry listener object and register it.</p>
				<h3 id="7-4-4-using-queue">7.4.4. Using Queue</h3>
				<p>Hazelcast Queue (<code>IQueue</code>) is a distributed queue which enables all cluster members to interact with it. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#queue">Queue section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Queue usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> queue;
<span class="hljs-comment">// Get a Blocking Queue called "my-distributed-queue"</span>
hz.getQueue(<span class="hljs-string">'my-distributed-queue'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">q</span>) </span>{
    queue = q;
    <span class="hljs-comment">// Offer a String into the Distributed Queue</span>
    <span class="hljs-keyword">return</span> queue.offer(<span class="hljs-string">'item'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Poll the Distributed Queue and return the String</span>
    <span class="hljs-keyword">return</span> queue.poll();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Timed blocking Operations</span>
    <span class="hljs-keyword">return</span> queue.offer(<span class="hljs-string">'anotheritem'</span>, <span class="hljs-number">500</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> queue.poll(<span class="hljs-number">5000</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Indefinitely blocking Operations</span>
    <span class="hljs-keyword">return</span> queue.put(<span class="hljs-string">'yetanotheritem'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> queue.take();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(value);
});
</code></pre>
				<p>Hazelcast Queue uses <code>ItemListener</code> to listen to the events that occur when the items are added to or removed from the Queue. See the <a href="#7523-item-listener">Item Listener section</a> for information on how to create an item listener object and register it.</p>
				<h2 id="7-4-5-using-set">7.4.5. Using Set</h2>
				<p>Hazelcast Set (<code>ISet</code>) is a distributed set which does not allow duplicate elements. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#set">Set section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Set usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> set;
<span class="hljs-comment">// Get the Distributed Set from Cluster.</span>
hz.getSet(<span class="hljs-string">'my-distributed-set'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
    set = s;
    <span class="hljs-comment">// Add items to the set with duplicates</span>
    <span class="hljs-keyword">return</span> set.add(<span class="hljs-string">'item1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> set.add(<span class="hljs-string">'item1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> set.add(<span class="hljs-string">'item2'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> set.add(<span class="hljs-string">'item2'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> set.add(<span class="hljs-string">'item2'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> set.add(<span class="hljs-string">'item3'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// Get the items. Note that there are no duplicates</span>
    <span class="hljs-keyword">return</span> set.toArray();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>{
    <span class="hljs-built_in">console</span>.log(values);
});
</code></pre>
				<p>Hazelcast Set uses <code>ItemListener</code> to listen to the events that occur when the items are added to or removed from the Set. See the <a href="#7523-item-listener">Item Listener section</a> for information on how to create an item listener object and register it.</p>
				<h2 id="7-4-6-using-list">7.4.6. Using List</h2>
				<p>Hazelcast List (<code>IList</code>) is a distributed list which allows duplicate elements and preserves the order of elements. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#list">List section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A List usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> list;
<span class="hljs-comment">// Get the Distributed List from Cluster.</span>
hz.getList(<span class="hljs-string">'my-distributed-list'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l</span>) </span>{
    list = l;
    <span class="hljs-comment">// Add elements to the list</span>
    <span class="hljs-keyword">return</span> list.add(<span class="hljs-string">'item1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> list.add(<span class="hljs-string">'item2'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//Remove the first element</span>
    <span class="hljs-keyword">return</span> list.removeAt(<span class="hljs-number">0</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(value);
    <span class="hljs-comment">// There is only one element left</span>
    <span class="hljs-keyword">return</span> list.size();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">len</span>) </span>{
    <span class="hljs-built_in">console</span>.log(len);
    <span class="hljs-comment">// Clear the list</span>
    <span class="hljs-keyword">return</span> list.clear();
});
</code></pre>
				<p>Hazelcast List uses <code>ItemListener</code> to listen to the events that occur when the items are added to or removed from the List. See the <a href="#7523-item-listener">Item Listener section</a> for information on how to create an item listener object and register it.</p>
				<h2 id="7-4-7-using-ringbuffer">7.4.7. Using Ringbuffer</h2>
				<p>Hazelcast <code>Ringbuffer</code> is a replicated but not partitioned data structure that stores its data in a ring-like structure. You can think of it as a circular array with a given capacity. Each Ringbuffer has a tail and a head. The tail is where the items are added and the head is where the items are overwritten or expired. You can reach each element in a Ringbuffer using a sequence ID, which is mapped to the elements between the head and tail (inclusive) of the Ringbuffer. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#ringbuffer">Ringbuffer section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Ringbuffer usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> rb;
<span class="hljs-comment">// Get a Ringbuffer called "rb"</span>
hz.getRingbuffer(<span class="hljs-string">'rb'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">buffer</span>) </span>{
    rb = buffer;
    <span class="hljs-keyword">return</span> rb.add(<span class="hljs-number">100</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> rb.add(<span class="hljs-number">200</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-comment">// we start from the oldest item.</span>
    <span class="hljs-comment">// if you want to start from the next item, call rb.tailSequence()+1</span>
    <span class="hljs-keyword">return</span> rb.headSequence();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">sequence</span>) </span>{
    <span class="hljs-keyword">return</span> rb.readOne(sequence).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-built_in">console</span>.log(value);
        <span class="hljs-keyword">return</span> rb.readOne(sequence.add(<span class="hljs-number">1</span>));
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
        <span class="hljs-built_in">console</span>.log(value);
    });
});
</code></pre>
				<h2 id="7-4-8-using-reliable-topic">7.4.8. Using Reliable Topic</h2>
				<p>Hazelcast <code>ReliableTopic</code> is a distributed topic implementation backed up by the <code>Ringbuffer</code> data structure. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#reliable-topic">Reliable Topic section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Reliable Topic usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> topic;
<span class="hljs-comment">// Get a Topic called "my-distributed-topic"</span>
hz.getReliableTopic(<span class="hljs-string">'my-distributed-topic'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>{
    topic = t;
    <span class="hljs-comment">// Add a Listener to the Topic</span>
    topic.addMessageListener(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
        <span class="hljs-built_in">console</span>.log(message);
    });
    <span class="hljs-comment">// Publish a message to the Topic</span>
    <span class="hljs-keyword">return</span> topic.publish(<span class="hljs-string">'Hello to distributed world'</span>);
});
</code></pre>
				<p>Hazelcast Reliable Topic uses <code>MessageListener</code> to listen to the events that occur when a message is received. See the <a href="#7524-message-listener">Message Listener section</a> for information on how to create a message listener object and register it.</p>
				<h2 id="7-4-9-using-lock">7.4.9. Using Lock</h2>
				<p>Hazelcast Lock (<code>ILock</code>) is a distributed lock implementation. You can synchronize Hazelcast members and clients using a Lock. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#lock">Lock section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Lock usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> lock;
<span class="hljs-comment">// Get a distributed lock called "my-distributed-lock"</span>
hz.getLock(<span class="hljs-string">'my-distributed-lock'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l</span>) </span>{
    lock = l;
    <span class="hljs-comment">// Now create a lock and execute some guarded code.</span>
    <span class="hljs-keyword">return</span> lock.lock();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// do something here</span>
}).finally(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> lock.unlock();
});
</code></pre>
				<h2 id="7-4-10-using-atomic-long">7.4.10. Using Atomic Long</h2>
				<p>Hazelcast Atomic Long (<code>IAtomicLong</code>) is the distributed long which offers most of the operations such as <code>get</code>, <code>set</code>, <code>getAndSet</code>, <code>compareAndSet</code> and <code>incrementAndGet</code>. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#iatomiclong">Atomic Long section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>An Atomic Long usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> counter;
<span class="hljs-comment">// Get an Atomic Counter, we'll call it "counter"</span>
hz.getAtomicLong(<span class="hljs-string">'counter'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>{
    counter = c;
    <span class="hljs-comment">// Add and Get the "counter"</span>
    <span class="hljs-keyword">return</span> counter.addAndGet(<span class="hljs-number">3</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> counter.get();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-comment">// Display the "counter" value</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'counter: '</span> + value);
});
</code></pre>
				<h2 id="7-4-11-using-semaphore">7.4.11. Using Semaphore</h2>
				<p>Hazelcast Semaphore (<code>ISemaphore</code>) is a distributed semaphore implementation. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#isemaphore">Semaphore section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Semaphore usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> semaphore;
hazelcastClient.getSemaphore(<span class="hljs-string">'mySemaphore'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>{
    semaphore = s;
    <span class="hljs-keyword">return</span> semaphore.init(<span class="hljs-number">10</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> semaphore.acquire(<span class="hljs-number">5</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> semaphore.availablePermits();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
    <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// 5</span>
});
</code></pre>
				<h2 id="7-4-12-using-pn-counter">7.4.12. Using PN Counter</h2>
				<p>Hazelcast <code>PNCounter</code> (Positive-Negative Counter) is a CRDT positive-negative counter implementation. It is an eventually consistent counter given there is no member failure. For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#pn-counter">PN Counter section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A PN Counter usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> pnCounter;
hz.getPNCounter(<span class="hljs-string">'myPNCounter'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">counter</span>) </span>{
    pnCounter = counter;
    <span class="hljs-keyword">return</span> pnCounter.get();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Counter started with value '</span> + value); <span class="hljs-comment">// 0</span>
    <span class="hljs-keyword">return</span> pnCounter.addAndGet(<span class="hljs-number">5</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Value after operation is '</span> + value); <span class="hljs-comment">// 5</span>
    <span class="hljs-keyword">return</span> pnCounter.getAndAdd(<span class="hljs-number">2</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Value before operation was '</span> + value); <span class="hljs-comment">// 5</span>
    <span class="hljs-keyword">return</span> pnCounter.get();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'New value is '</span> + value); <span class="hljs-comment">// 7</span>
    <span class="hljs-keyword">return</span> pnCounter.decrementAndGet();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Decremented counter by one. New value is '</span> + value); <span class="hljs-comment">// 6</span>
});
</code></pre>
				<h2 id="7-4-13-using-flake-id-generator">7.4.13. Using Flake ID Generator</h2>
				<p>Hazelcast <code>FlakeIdGenerator</code> is used to generate cluster-wide unique identifiers. Generated identifiers are long primitive values and are k-ordered (roughly ordered). IDs are in the range from 0 to <code>2^63-1</code> (maximum signed long value). For details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#flakeidgenerator">FlakeIdGenerator section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>A Flake ID Generator usage example is shown below.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> flakeIdGenerator;
hz.getFlakeIdGenerator(<span class="hljs-string">'myFlakeIdGenerator'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">gen</span>) </span>{
    flakeIdGenerator = gen;
    <span class="hljs-keyword">return</span> flakeIdGenerator.newId();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'New id: '</span> + value.toString());
});
</code></pre>
				<h2 id="7-5-distributed-events">7.5. Distributed Events</h2>
				<p>This chapter explains when various events are fired and describes how you can add event listeners on a Hazelcast Node.js client. These events can be categorized as cluster and distributed data structure events.</p>
				<h3 id="7-5-1-listening-for-cluster-events">7.5.1. Listening for Cluster Events</h3>
				<p>You can add event listeners to a Hazelcast Node.js client. You can configure the following listeners to listen to the events on the client side:</p>
				<ul>
					<li>Membership Listener: Notifies when a member joins to/leaves the cluster, or when an attribute is changed in a member.</li>
					<li>Distributed Object Listener: Notifies when a distributed object is created or destroyed throughout the cluster.</li>
					<li>Lifecycle Listener: Notifies when the client is starting, started, shutting down and shutdown.</li>
				</ul>
				<h4 id="7-5-1-1-membership-listener">7.5.1.1. Membership Listener</h4>
				<p>The Membership Listener interface has functions that are invoked for the following events.</p>
				<ul>
					<li><code>memberAdded</code>: A new member is added to the cluster.</li>
					<li><code>memberRemoved</code>: An existing member leaves the cluster.</li>
					<li><code>memberAttributeChanged</code>: An attribute of a member is changed. See the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#defining-member-attributes">Defining Member Attributes section</a> in the Hazelcast IMDG Reference Manual to learn about member attributes.</li>
				</ul>
				<p>For <code>memberAdded</code> and <code>memberRemoved</code> events, a <code>MembershipEvent</code> object is passed to the listener function.</p>
				<p>After you create the listener object, you can configure your cluster to include the membership listener. You can also add one or more membership listeners.</p>
				<p>The following is a membership listener registration by using the <code>ClusterService.addMembershipListener()</code> function.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> membershipListener = {
    <span class="hljs-attr">memberAdded</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">membershipEvent</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Member Added: The address is'</span>, member.address.toString());
    },
};
client.clusterService.addMembershipListener(membershipListener);
</code></pre>
				<p>The <code>memberAttributeChanged</code> has its own type of event named as <code>MemberAttributeEvent</code>. When there is an attribute change on the member, this event is fired.</p>
				<p>See the following example.</p>
				<pre><code class="lang-javascript">
<span class="hljs-keyword">var</span> membershipListener = {
    <span class="hljs-attr">memberAttributeChanged</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">memberAttributeEvent</span>) </span>{
       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Member Attribute Changed: The address is'</span>, memberAttributeEvent.member.address.toString());
    },
};
client.clusterService.addMembershipListener(membershipListener);
</code></pre>
				<h4 id="7-5-1-2-distributed-object-listener">7.5.1.2. Distributed Object Listener</h4>
				<p>The events for distributed objects are invoked when they are created and destroyed in the cluster. After the events, a listener callback function is called. The type of the callback function should be <code>DistributedObjectListener</code>. The parameter of the function is <code>DistributedObjectEvent</code> including following fields:</p>
				<ul>
					<li><code>serviceName</code>: Service name of the distributed object.</li>
					<li><code>objectName</code>: Name of the distributed object.</li>
					<li><code>eventType</code>: Type of the invoked event. It can be <code>created</code> or <code>destroyed</code>.</li>
				</ul>
				<p>The following is an example of adding a <code>DistributedObjectListener</code>.</p>
				<pre><code class="lang-javascript">client.addDistributedObjectListener(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">distributedObjectEvent</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Distributed object event &gt;&gt;&gt; '</span>,
        distributedObjectEvent.serviceName,
        distributedObjectEvent.objectName,
        distributedObjectEvent.eventType
    );
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> mapname = <span class="hljs-string">'test'</span>;
    <span class="hljs-comment">// this causes a created event</span>
    client.getMap(mapname);
    <span class="hljs-comment">// this causes no event because map was already created</span>
    client.getMap(mapname);
});
</code></pre>
				<h4 id="7-5-1-3-lifecycle-listener">7.5.1.3. Lifecycle Listener</h4>
				<p>The <code>LifecycleListener</code> interface notifies for the following events:</p>
				<ul>
					<li><code>starting</code>: A client is starting.</li>
					<li><code>started</code>: A client has started.</li>
					<li><code>shuttingDown</code>: A client is shutting down.</li>
					<li><code>shutdown</code>: A client’s shutdown has completed.</li>
				</ul>
				<p>The following is an example of the <code>LifecycleListener</code> that is added to the <code>ClientConfig</code> object and its output.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> clientConfig = <span class="hljs-keyword">new</span> Config.ClientConfig();
clientConfig.listeners.addLifecycleListener(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">state</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Lifecycle Event &gt;&gt;&gt; '</span> + state);
});

Client.newHazelcastClient(clientConfig).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hazelcastClient</span>) </span>{
    hazelcastClient.shutdown();
});
</code></pre>
				<p><strong>Output:</strong></p>
				<pre><code><span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">LifecycleService:</span> <span class="hljs-string">HazelcastClient</span> <span class="hljs-string">is</span> <span class="hljs-string">starting</span>
<span class="hljs-string">Lifecycle</span> <span class="hljs-string">Event</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-string">starting</span>
<span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">ConnectionAuthenticator:</span> <span class="hljs-string">Connection</span> <span class="hljs-string">to</span> <span class="hljs-number">10.216</span><span class="hljs-number">.1</span><span class="hljs-number">.43</span><span class="hljs-string">:5701</span> <span class="hljs-string">authenticated</span>
<span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">ClusterService:</span> <span class="hljs-string">Members</span> <span class="hljs-string">received.</span>
<span class="hljs-string">[</span> <span class="hljs-string">Member</span> <span class="hljs-string">{</span>
<span class="hljs-attr">    address:</span> <span class="hljs-string">Address</span> <span class="hljs-string">{</span> <span class="hljs-attr">host:</span> <span class="hljs-string">'10.216.1.43'</span><span class="hljs-string">,</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5701</span><span class="hljs-string">,</span> <span class="hljs-attr">type:</span> <span class="hljs-number">4</span> <span class="hljs-string">},</span>
<span class="hljs-attr">    uuid:</span> <span class="hljs-string">'7961eef2-940d-42dc-8036-2a29c5c9942c'</span><span class="hljs-string">,</span>
<span class="hljs-attr">    isLiteMember:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span>
<span class="hljs-attr">    attributes:</span> <span class="hljs-string">{}</span> <span class="hljs-string">}</span> <span class="hljs-string">]</span>
<span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">LifecycleService:</span> <span class="hljs-string">HazelcastClient</span> <span class="hljs-string">is</span> <span class="hljs-string">started</span>
<span class="hljs-string">Lifecycle</span> <span class="hljs-string">Event</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-string">started</span>
<span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">LifecycleService:</span> <span class="hljs-string">HazelcastClient</span> <span class="hljs-string">is</span> <span class="hljs-string">shuttingDown</span>
<span class="hljs-string">Lifecycle</span> <span class="hljs-string">Event</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-string">shuttingDown</span>
<span class="hljs-string">[DefaultLogger]</span> <span class="hljs-string">INFO</span> <span class="hljs-string">at</span> <span class="hljs-attr">LifecycleService:</span> <span class="hljs-string">HazelcastClient</span> <span class="hljs-string">is</span> <span class="hljs-string">shutdown</span>
<span class="hljs-string">Lifecycle</span> <span class="hljs-string">Event</span> <span class="hljs-string">&gt;&gt;&gt;</span> <span class="hljs-string">shutdown</span>
</code></pre><h3 id="7-5-2-listening-for-distributed-data-structure-events">7.5.2. Listening for Distributed Data Structure Events</h3>
				<p>You can add event listeners to the distributed data structures.</p>
				<blockquote>
					<p><strong>NOTE: Hazelcast Node.js client is a TypeScript-based project but JavaScript does not have interfaces. Therefore,
					some interfaces are given to the user by using the TypeScript files that have <code>.ts</code> extension. In this guide, implementing an interface means creating an object to have the necessary functions that are listed in the interface inside the <code>.ts</code> file. Also, this object is mentioned as <code>an instance of the interface</code>. You can search the <a href="http://hazelcast.github.io/hazelcast-nodejs-client/api/current/docs/">API Documentation</a> or GitHub repository for a required interface.</strong></p>
				</blockquote>
				<h4 id="7-5-2-1-map-listener">7.5.2.1. Map Listener</h4>
				<p>The Map Listener is used by the Hazelcast <code>Map</code>.</p>
				<p>You can listen to map-wide or entry-based events by using the functions in the <code>MapListener</code> interface. Every function type in this interface is one of the <code>EntryEventListener</code> and <code>MapEventListener</code> types. To listen to these events, you need to implement the relevant <code>EntryEventListener</code> and <code>MapEventListener</code> functions in the <code>MapListener</code> interface.</p>
				<p>An entry-based event is fired after the operations that affect a specific entry. For example, <code>IMap.put()</code>, <code>IMap.remove()</code> or <code>IMap.evict()</code>. You should use the <code>EntryEventListener</code> type to listen to these events. An <code>EntryEvent</code> object is passed to the listener function.</p>
				<p>See the following example.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> entryEventListener = {
    <span class="hljs-attr">added</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entryEvent</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Entry Added:'</span>, entryEvent.key, <span class="hljs-string">'--&gt;'</span>, entryEvent.value); <span class="hljs-comment">// Entry Added: 1 --&gt; My new entry</span>
    }
};
map.addEntryListener(entryEventListener, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'1'</span>, <span class="hljs-string">'My new entry'</span>);
});
</code></pre>
				<p>A map-wide event is fired as a result of a map-wide operation. For example, <code>IMap.clear()</code> or <code>IMap.evictAll()</code>. You should use the <code>MapEventListener</code> type to listen to these events. A <code>MapEvent</code> object is passed to the listener function.</p>
				<p>See the following example.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mapEventListener = {
    <span class="hljs-attr">mapCleared</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mapEvent</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Map Cleared:'</span>, mapEvent.numberOfAffectedEntries); <span class="hljs-comment">// Map Cleared: 3</span>
    }
};
map.addEntryListener(mapEventListener).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'1'</span>, <span class="hljs-string">'Muhammad Ali'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'2'</span>, <span class="hljs-string">'Mike Tyson'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'3'</span>, <span class="hljs-string">'Joe Louis'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.clear();
});
</code></pre>
				<p>As you see, there is a parameter in the <code>addEntryListener</code> function: <code>includeValue</code>. It is a boolean parameter, and if it is <code>true</code>, the map event contains the entry value.</p>
				<h4 id="7-5-2-2-entry-listener">7.5.2.2. Entry Listener</h4>
				<p>The Entry Listener is used by the Hazelcast <code>MultiMap</code> and <code>ReplicatedMap</code>.</p>
				<p>You can listen to map-wide or entry-based events by using the functions in the <code>EntryListener</code> interface. Every function type in this interface is one of the <code>EntryEventListener</code> and <code>MapEventListener</code> types. To listen to these events, you need to implement the relevant <code>EntryEventListener</code> and <code>MapEventListener</code> functions in the <code>EntryListener</code> interface.</p>
				<p>An entry-based event is fired after the operations that affect a specific entry. For example, <code>MultiMap.put()</code>, <code>MultiMap.remove()</code>. You should use the <code>EntryEventListener</code> type to listen to these events. An <code>EntryEvent</code> object is passed to the listener function.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> entryEventListener = {
    <span class="hljs-attr">added</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">entryEvent</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Entry Added:'</span>, entryEvent.key, <span class="hljs-string">'--&gt;'</span>, entryEvent.value); <span class="hljs-comment">// Entry Added: 1 --&gt; My new entry</span>
    }
};
<span class="hljs-keyword">return</span> mmp.addEntryListener(entryEventListener, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> mmp.put(<span class="hljs-string">'1'</span>, <span class="hljs-string">'My new entry'</span>);
});
</code></pre>
				<p>A map-wide event is fired as a result of a map-wide operation. For example, <code>MultiMap.clear()</code>. You should use the <code>MapEventListener</code> type to listen to these events. A <code>MapEvent</code> object is passed to the listener function.</p>
				<p>See the following example.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> mapEventListener = {
    <span class="hljs-attr">mapCleared</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mapEvent</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Map Cleared:'</span>, mapEvent.numberOfAffectedEntries); <span class="hljs-comment">// Map Cleared: 1</span>
    }
};
mmp.addEntryListener(mapEventListener).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> mmp.put(<span class="hljs-string">'1'</span>, <span class="hljs-string">'Muhammad Ali'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> mmp.put(<span class="hljs-string">'1'</span>, <span class="hljs-string">'Mike Tyson'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> mmp.put(<span class="hljs-string">'1'</span>, <span class="hljs-string">'Joe Louis'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> mmp.clear();
});
</code></pre>
				<p>Note that all functions in the <code>EntryListener</code> interface is not supported by MultiMap and Replicated Map. See the following headings to see supported listener functions for each data structure.</p>
				<p><strong>Entry Listener Functions Supported by MultiMap</strong></p>
				<ul>
					<li><code>added</code></li>
					<li><code>removed</code></li>
					<li><code>mapCleared</code></li>
				</ul>
				<p><strong>Entry Listener Functions Supported by Replicated Map</strong></p>
				<ul>
					<li><code>added</code></li>
					<li><code>removed</code></li>
					<li><code>updated</code></li>
					<li><code>evicted</code></li>
					<li><code>mapCleared</code></li>
				</ul>
				<p>As you see, there is a parameter in the <code>addEntryListener</code> function: <code>includeValue</code>. It is a boolean parameter, and if it is <code>true</code>, the entry event contains the entry value.</p>
				<h4 id="7-5-2-3-item-listener">7.5.2.3. Item Listener</h4>
				<p>The Item Listener is used by the Hazelcast <code>Queue</code>, <code>Set</code> and <code>List</code>.</p>
				<p>You can listen to item events by implementing the functions in the <code>ItemListener</code> interface including <code>itemAdded</code> and <code>itemRemoved</code>. These functions are invoked when an item is added or removed.</p>
				<p>The following is an example of item listener object and its registration to the <code>Set</code>. It also applies to <code>Queue</code> and <code>List</code>.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> itemListener = {
    <span class="hljs-attr">itemAdded</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">itemEvent</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Item Added:'</span>, itemEvent.item); <span class="hljs-comment">// Item Added: Item1</span>
    },
    <span class="hljs-attr">itemRemoved</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">itemEvent</span>) </span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Item Removed:'</span>, itemEvent.item); <span class="hljs-comment">// Item Removed: Item1</span>
    }
};
<span class="hljs-keyword">return</span> set.addItemListener(itemListener, <span class="hljs-literal">true</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> set.add(<span class="hljs-string">'Item1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> set.remove(<span class="hljs-string">'Item1'</span>);
});
</code></pre>
				<p>As you see, there is a parameter in the <code>addItemListener</code> function: <code>includeValue</code>. It is a boolean parameter, and if it is <code>true</code>, the item event contains the item value.</p>
				<h4 id="7-5-2-4-message-listener">7.5.2.4. Message Listener</h4>
				<p>The Message Listener is used by the Hazelcast <code>Reliable Topic</code>.</p>
				<p>You can listen to message events. To listen to these events, you need to implement the <code>MessageListener</code> function to which a <code>Message</code> object is passed.</p>
				<p>See the following example.</p>
				<pre><code class="lang-javascript">topic.addMessageListener(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
    <span class="hljs-built_in">console</span>.log(message.messageObject);
});

<span class="hljs-keyword">var</span> movie = {
    <span class="hljs-attr">title</span>: <span class="hljs-string">'The Prestige'</span>,
    <span class="hljs-attr">year</span>: <span class="hljs-string">'2006'</span>,
    <span class="hljs-attr">runtime</span>: <span class="hljs-string">'130 min'</span>,
    <span class="hljs-attr">director</span>: <span class="hljs-string">'Christopher Nolan'</span>,
    <span class="hljs-attr">imdbRating</span>: <span class="hljs-string">'8.5'</span>
}
topic.publish(movie);
</code></pre>
				<h2 id="7-6-distributed-computing">7.6. Distributed Computing</h2>
				<p>This chapter explains how you can use Hazelcast IMDG&#39;s entry processor implementation in the Node.js client.</p>
				<h3 id="7-6-1-using-entryprocessor">7.6.1. Using EntryProcessor</h3>
				<p>Hazelcast supports entry processing. An entry processor is a function that executes your code on a map entry in an atomic way.</p>
				<p>An entry processor is a good option if you perform bulk processing on an <code>IMap</code>. Usually you perform a loop of keys -- executing <code>IMap.get(key)</code>, mutating the value and finally putting the entry back in the map using <code>IMap.put(key,value)</code>. If you perform this process from a client or from a member where the keys do not exist, you effectively perform two network hops for each update: the first to retrieve the data and the second to update the mutated value.</p>
				<p>If you are doing the process described above, you should consider using entry processors. An entry processor executes a read and updates upon the member where the data resides. This eliminates the costly network hops described above.</p>
				<blockquote>
					<p><strong>NOTE: Entry processor is meant to process a single entry per call. Processing multiple entries and data structures in an entry processor is not supported as it may result in deadlocks on the server side.</strong></p>
				</blockquote>
				<p>Hazelcast sends the entry processor to each cluster member and these members apply it to the map entries. Therefore, if you add more members, your processing completes faster.</p>
				<h4 id="processing-entries">Processing Entries</h4>
				<p>The <code>IMap</code> interface provides the following functions for entry processing:</p>
				<ul>
					<li><code>executeOnKey</code> processes an entry mapped by a key.</li>
					<li><code>executeOnKeys</code> processes entries mapped by a list of keys.</li>
					<li><code>executeOnEntries</code> can process all entries in a map with a defined predicate. Predicate is optional.</li>
				</ul>
				<p>In the Node.js client, an <code>EntryProcessor</code> should be <code>IdentifiedDataSerializable</code> or <code>Portable</code> because the server should be able to deserialize it to process.</p>
				<p>The following is an example for <code>EntryProcessor</code> which is <code>IdentifiedDataSerializable</code>.</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IdentifiedEntryProcessor</span>(<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">this</span>.value = value;
}

IdentifiedEntryProcessor.prototype.readData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">inp</span>) </span>{
    <span class="hljs-keyword">this</span>.value = inp.readUTF();
};

IdentifiedEntryProcessor.prototype.writeData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">outp</span>) </span>{
    outp.writeUTF(<span class="hljs-keyword">this</span>.value);
};

IdentifiedEntryProcessor.prototype.getFactoryId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;
};

IdentifiedEntryProcessor.prototype.getClassId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
};
</code></pre>
				<p>Now, you need to make sure that the Hazelcast member recognizes the entry processor. For this, you need to implement the Java equivalent of your entry processor and its factory, and create your own compiled class or JAR files. For adding your own compiled class or JAR files to the server&#39;s <code>CLASSPATH</code>, see the <a href="#1212-adding-user-library-to-classpath">Adding User Library to CLASSPATH section</a>.</p>
				<p>The following is the Java equivalent of the entry processor in Node.js client given above:</p>
				<pre><code class="lang-java"><span class="hljs-keyword">import</span> com.hazelcast.map.AbstractEntryProcessor;
<span class="hljs-keyword">import</span> com.hazelcast.nio.ObjectDataInput;
<span class="hljs-keyword">import</span> com.hazelcast.nio.ObjectDataOutput;
<span class="hljs-keyword">import</span> com.hazelcast.nio.serialization.IdentifiedDataSerializable;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdentifiedEntryProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEntryProcessor</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">String</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">IdentifiedDataSerializable</span> </span>{
     <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CLASS_ID = <span class="hljs-number">1</span>;
     <span class="hljs-keyword">private</span> String value;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdentifiedEntryProcessor</span><span class="hljs-params">()</span> </span>{
    }

     <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFactoryId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> IdentifiedFactory.FACTORY_ID;
    }

     <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> CLASS_ID;
    }

     <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeData</span><span class="hljs-params">(ObjectDataOutput out)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        out.writeUTF(value);
    }

     <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readData</span><span class="hljs-params">(ObjectDataInput in)</span> <span class="hljs-keyword">throws</span> IOException </span>{
        value = in.readUTF();
    }

     <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">process</span><span class="hljs-params">(Map.Entry&lt;String, String&gt; entry)</span> </span>{
        entry.setValue(value);
        <span class="hljs-keyword">return</span> value;
    }
}
</code></pre>
				<p>You can implement the above processor’s factory as follows:</p>
				<pre><code class="lang-java"><span class="hljs-keyword">import</span> com.hazelcast.nio.serialization.DataSerializableFactory;
<span class="hljs-keyword">import</span> com.hazelcast.nio.serialization.IdentifiedDataSerializable;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdentifiedFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DataSerializableFactory</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> FACTORY_ID = <span class="hljs-number">5</span>;

     <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> IdentifiedDataSerializable <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> typeId)</span> </span>{
        <span class="hljs-keyword">if</span> (typeId == IdentifiedEntryProcessor.CLASS_ID) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IdentifiedEntryProcessor();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre>
				<p>Now you need to configure the <code>hazelcast.xml</code> to add your factory as shown below.</p>
				<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hazelcast</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">serialization</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">data-serializable-factories</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">data-serializable-factory</span> <span class="hljs-attr">factory-id</span>=<span class="hljs-string">"5"</span>&gt;</span>
                IdentifiedFactory
            <span class="hljs-tag">&lt;/<span class="hljs-name">data-serializable-factory</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">data-serializable-factories</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">serialization</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">hazelcast</span>&gt;</span>
</code></pre>
				<p>The code that runs on the entries is implemented in Java on the server side. The client side entry processor is used to specify which entry processor should be called. For more details about the Java implementation of the entry processor, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/index.html#entry-processor">Entry Processor section</a> in the Hazelcast IMDG Reference Manual.</p>
				<p>After the above implementations and configuration are done and you start the server where your library is added to its <code>CLASSPATH</code>, you can use the entry processor in the <code>IMap</code> functions. See the following example.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map;
hazelcastClient.getMap(<span class="hljs-string">'my-distributed-map'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    map = mp;
    <span class="hljs-keyword">return</span> map.put(<span class="hljs-string">'key'</span>, <span class="hljs-string">'not-processed'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.executeOnKey(<span class="hljs-string">'key'</span>, <span class="hljs-keyword">new</span> IdentifiedEntryProcessor(<span class="hljs-string">'processed'</span>));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.get(<span class="hljs-string">'key'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// processed</span>
});
</code></pre>
				<h2 id="7-7-distributed-query">7.7. Distributed Query</h2>
				<p>Hazelcast partitions your data and spreads it across cluster of members. You can iterate over the map entries and look for certain entries (specified by predicates) you are interested in. However, this is not very efficient because you will have to bring the entire entry set and iterate locally. Instead, Hazelcast allows you to run distributed queries on your distributed map.</p>
				<h3 id="7-7-1-how-distributed-query-works">7.7.1. How Distributed Query Works</h3>
				<ol>
					<li>The requested predicate is sent to each member in the cluster.</li>
					<li>Each member looks at its own local entries and filters them according to the predicate. At this stage, key-value pairs of the entries are deserialized and then passed to the predicate.</li>
					<li>The predicate requester merges all the results coming from each member into a single set.</li>
				</ol>
				<p>Distributed query is highly scalable. If you add new members to the cluster, the partition count for each member is reduced and thus the time spent by each member on iterating its entries is reduced. In addition, the pool of partition threads evaluates the entries concurrently in each member, and the network traffic is also reduced since only filtered data is sent to the requester.</p>
				<p><strong>Predicates Object Operators</strong></p>
				<p>The <code>Predicates</code> object offered by the Node.js client includes many operators for your query requirements. Some of them are described below.</p>
				<ul>
					<li><code>equal</code>: Checks if the result of an expression is equal to a given value.</li>
					<li><code>notEqual</code>: Checks if the result of an expression is not equal to a given value.</li>
					<li><code>instanceOf</code>: Checks if the result of an expression has a certain type.</li>
					<li><code>like</code>: Checks if the result of an expression matches some string pattern. <code>%</code> (percentage sign) is the placeholder for many characters, <code>_</code> (underscore) is the placeholder for only one character.</li>
					<li><code>greaterThan</code>: Checks if the result of an expression is greater than a certain value.</li>
					<li><code>greaterEqual</code>: Checks if the result of an expression is greater than or equal to a certain value.</li>
					<li><code>lessThan</code>: Checks if the result of an expression is less than a certain value.</li>
					<li><code>lessEqual</code>: Checks if the result of an expression is less than or equal to a certain value.</li>
					<li><code>between</code>: Checks if the result of an expression is between two values, inclusively.</li>
					<li><code>inPredicate</code>: Checks if the result of an expression is an element of a certain list.</li>
					<li><code>not</code>: Checks if the result of an expression is false.</li>
					<li><code>regex</code>: Checks if the result of an expression matches some regular expression.</li>
				</ul>
				<p>Hazelcast offers the following ways for distributed query purposes:</p>
				<ul>
					<li>Combining Predicates with AND, OR, NOT</li>
					<li>Distributed SQL Query</li>
				</ul>
				<h4 id="7-7-1-1-employee-map-query-example">7.7.1.1. Employee Map Query Example</h4>
				<p>Assume that you have an <code>employee</code> map containing the values of <code>Employee</code> objects, as coded below.</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Employee</span>(<span class="hljs-params">name, age, active, salary</span>) </span>{
    <span class="hljs-keyword">this</span>.name = name;
    <span class="hljs-keyword">this</span>.age = age;
    <span class="hljs-keyword">this</span>.active = active;
    <span class="hljs-keyword">this</span>.salary = salary;
}

Employee.prototype.getClassId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

Employee.prototype.getFactoryId = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

Employee.prototype.readPortable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reader</span>) </span>{
    <span class="hljs-keyword">this</span>.name = reader.readUTF();
    <span class="hljs-keyword">this</span>.age = reader.readInt();
    <span class="hljs-keyword">this</span>.active = reader.readBoolean();
    <span class="hljs-keyword">this</span>.salary = reader.readDouble();
}

Employee.prototype.writePortable = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">writer</span>) </span>{
    writer.writeUTF(<span class="hljs-keyword">this</span>.name);
    writer.writeInt(<span class="hljs-keyword">this</span>.age);
    writer.writeBoolean(<span class="hljs-keyword">this</span>.active);
    writer.writeDouble(<span class="hljs-keyword">this</span>.salary);
}
</code></pre>
				<p>Note that <code>Employee</code> is a <code>Portable</code> object. As portable types are not deserialized on the server side for querying, you don&#39;t need to implement its Java equivalent on the server side.</p>
				<p>For the non-portable types, you need to implement its Java equivalent and its serializable factory on the server side for server to reconstitute the objects from binary formats. In this case before starting the server, you need to compile the Employee and related factory classes with server&#39;s CLASSPATH and add them to the user-lib directory in the extracted hazelcast-<version>.zip (or tar).  See the <a href="#1212-adding-user-library-to-classpath">Adding User Library to CLASSPATH section</a>.</p>
				<blockquote>
					<p><strong>NOTE: Querying with <code>Portable</code> object is faster as compared to <code>IdentifiedDataSerializable</code>.</strong></p>
				</blockquote>
				<h4 id="7-7-1-2-querying-by-combining-predicates-with-and-or-not">7.7.1.2. Querying by Combining Predicates with AND, OR, NOT</h4>
				<p>You can combine predicates by using the <code>and</code>, <code>or</code> and <code>not</code> operators, as shown in the below example.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map;
client.getMap(<span class="hljs-string">'employee'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    map = mp;
    <span class="hljs-keyword">var</span> predicate = Predicates.and(Predicates.equal(<span class="hljs-string">'active'</span>, <span class="hljs-literal">true</span>), Predicates.lessThan(<span class="hljs-string">'age'</span>, <span class="hljs-number">30</span>));
    <span class="hljs-keyword">return</span> map.valuesWithPredicate(predicate);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">employees</span>) </span>{
    <span class="hljs-comment">// some operations</span>
});
</code></pre>
				<p>In the above example code, <code>predicate</code> verifies whether the entry is active and its <code>age</code> value is less than 30. This <code>predicate</code> is applied to the <code>employee</code> map using the <code>map.valuesWithPredicate(predicate)</code> method. This method sends the predicate to all cluster members and merges the results coming from them.</p>
				<blockquote>
					<p><strong>NOTE: Predicates can also be applied to <code>keySet</code> and <code>entrySet</code> of the Hazelcast IMDG&#39;s distributed map.</strong></p>
				</blockquote>
				<h4 id="7-7-1-3-querying-with-sql">7.7.1.3. Querying with SQL</h4>
				<p><code>SqlPredicate</code> takes the regular SQL <code>where</code> clause. See the following example:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map;
client.getMap(<span class="hljs-string">'employee'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    map = mp;
    <span class="hljs-keyword">return</span> map.valuesWithPredicate(<span class="hljs-keyword">new</span> SqlPredicate(<span class="hljs-string">'active AND age &lt; 30'</span>));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">employees</span>) </span>{
    <span class="hljs-comment">// some operations</span>
});
</code></pre>
				<h5 id="supported-sql-syntax">Supported SQL Syntax</h5>
				<p><strong>AND/OR:</strong> <code>&lt;expression&gt; AND &lt;expression&gt; AND &lt;expression&gt;…</code></p>
				<ul>
					<li><code>active AND age &gt; 30</code></li>
					<li><code>active = false OR age = 45 OR name = &#39;Joe&#39;</code></li>
					<li><code>active AND ( age &gt; 20 OR salary &lt; 60000 )</code></li>
				</ul>
				<p><strong>Equality:</strong> <code>=, !=, &lt;, ⇐, &gt;, &gt;=</code></p>
				<ul>
					<li><code>&lt;expression&gt; = value</code></li>
					<li><code>age &lt;= 30</code></li>
					<li><code>name = &#39;Joe&#39;</code></li>
					<li><code>salary != 50000</code></li>
				</ul>
				<p><strong>BETWEEN:</strong> <code>&lt;attribute&gt; [NOT] BETWEEN &lt;value1&gt; AND &lt;value2&gt;</code></p>
				<ul>
					<li><code>age BETWEEN 20 AND 33 ( same as age &gt;= 20 AND age ⇐ 33 )</code></li>
					<li><code>age NOT BETWEEN 30 AND 40 ( same as age &lt; 30 OR age &gt; 40 )</code></li>
				</ul>
				<p><strong>IN:</strong> <code>&lt;attribute&gt; [NOT] IN (val1, val2,…)</code></p>
				<ul>
					<li><code>age IN ( 20, 30, 40 )</code></li>
					<li><code>age NOT IN ( 60, 70 )</code></li>
					<li><code>active AND ( salary &gt;= 50000 OR ( age NOT BETWEEN 20 AND 30 ) )</code></li>
					<li><code>age IN ( 20, 30, 40 ) AND salary BETWEEN ( 50000, 80000 )</code></li>
				</ul>
				<p><strong>LIKE:</strong> <code>&lt;attribute&gt; [NOT] LIKE &#39;expression&#39;</code></p>
				<p>The <code>%</code> (percentage sign) is the placeholder for multiple characters, an <code>_</code> (underscore) is the placeholder for only one character.</p>
				<ul>
					<li><code>name LIKE &#39;Jo%&#39;</code> (true for &#39;Joe&#39;, &#39;Josh&#39;, &#39;Joseph&#39; etc.)</li>
					<li><code>name LIKE &#39;Jo_&#39;</code> (true for &#39;Joe&#39;; false for &#39;Josh&#39;)</li>
					<li><code>name NOT LIKE &#39;Jo_&#39;</code> (true for &#39;Josh&#39;; false for &#39;Joe&#39;)</li>
					<li><code>name LIKE &#39;J_s%&#39;</code> (true for &#39;Josh&#39;, &#39;Joseph&#39;; false &#39;John&#39;, &#39;Joe&#39;)</li>
				</ul>
				<p><strong>ILIKE:</strong> <code>&lt;attribute&gt; [NOT] ILIKE &#39;expression&#39;</code></p>
				<p>ILIKE is similar to the LIKE predicate but in a case-insensitive manner.</p>
				<ul>
					<li><code>name ILIKE &#39;Jo%&#39;</code> (true for &#39;Joe&#39;, &#39;joe&#39;, &#39;jOe&#39;,&#39;Josh&#39;,&#39;joSH&#39;, etc.)</li>
					<li><code>name ILIKE &#39;Jo_&#39;</code> (true for &#39;Joe&#39; or &#39;jOE&#39;; false for &#39;Josh&#39;)</li>
				</ul>
				<p><strong>REGEX:</strong> <code>&lt;attribute&gt; [NOT] REGEX &#39;expression&#39;</code></p>
				<ul>
					<li><code>name REGEX &#39;abc-.*&#39;</code> (true for &#39;abc-123&#39;; false for &#39;abx-123&#39;)</li>
				</ul>
				<h5 id="querying-examples-with-predicates">Querying Examples with Predicates</h5>
				<p>You can use the <code>__key</code> attribute to perform a predicated search for the entry keys. See the following example:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> personMap;
client.getMap(<span class="hljs-string">'persons'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    personMap = mp;
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-string">'Alice'</span>, <span class="hljs-number">35</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-string">'Andy'</span>, <span class="hljs-number">37</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-string">'Bob'</span>, <span class="hljs-number">22</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> predicate = <span class="hljs-keyword">new</span> Predicates.sql(<span class="hljs-string">'__key like A%'</span>);
    <span class="hljs-keyword">return</span> personMap.valuesWithPredicate(predicate);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">startingWithA</span>) </span>{
    <span class="hljs-built_in">console</span>.log(startingWithA.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">// 35</span>
});
</code></pre>
				<p>In this example, the code creates a list with the values whose keys start with the letter &quot;A”.</p>
				<p>You can use the <code>this</code> attribute to perform a predicated search for entry values. See the following example:</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> personMap;
<span class="hljs-keyword">return</span> client.getMap(<span class="hljs-string">'persons'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    personMap = mp;
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-string">'Alice'</span>, <span class="hljs-number">35</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-string">'Andy'</span>, <span class="hljs-number">37</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-string">'Bob'</span>, <span class="hljs-number">22</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> predicate = <span class="hljs-keyword">new</span> Predicates.greaterEqual(<span class="hljs-string">'this'</span>, <span class="hljs-number">27</span>);
    <span class="hljs-keyword">return</span> personMap.valuesWithPredicate(predicate);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">olderThan27</span>) </span>{
    <span class="hljs-built_in">console</span>.log(olderThan27.get(<span class="hljs-number">0</span>), olderThan27.get(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 35 37</span>
});
</code></pre>
				<p>In this example, the code creates a list with the values greater than or equal to &quot;27&quot;.</p>
				<h4 id="7-7-1-4-querying-with-json-strings">7.7.1.4. Querying with JSON Strings</h4>
				<p>You can query the JSON strings stored inside your Hazelcast clusters. To query a JSON string, you can
				use <code>HazelcastJsonValue</code> or JavaScript objects. </p>
				<p><code>HazelcastJsonValue</code> objects can be used both as keys and values in the distributed data structures.
				Then, it is possible to query these objects using the query methods explained in this section.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> personMap;
<span class="hljs-keyword">var</span> person1 = <span class="hljs-string">'{ "name": "John", "age": 35 }'</span>;
<span class="hljs-keyword">var</span> person2 = <span class="hljs-string">'{ "name": "Jane", "age": 24 }'</span>;
<span class="hljs-keyword">var</span> person3 = <span class="hljs-string">'{ "name": "Trey", "age": 17 }'</span>;

<span class="hljs-keyword">return</span> hz.getMap(<span class="hljs-string">'personsMap'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">map</span>) </span>{
    personMap = map;
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> HazelcastJsonValue(person1));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> HazelcastJsonValue(person2));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> personMap.put(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> HazelcastJsonValue(person3));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> personMap.valuesWithPredicate(Predicates.lessThan(<span class="hljs-string">'age'</span>, <span class="hljs-number">21</span>));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">personsUnder21</span>) </span>{
    personsUnder21.toArray().forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">person</span>) </span>{
        <span class="hljs-built_in">console</span>.log(person);
    });
});
</code></pre>
				<p>When running the queries, Hazelcast treats values extracted from the JSON documents as Java types so they can be compared with the query attribute.
					JSON specification defines five primitive types to be used in the JSON documents: <code>number</code>, <code>string</code>, <code>true</code>, <code>false</code> and <code>null</code>.
					The <code>string</code>, <code>true</code>/<code>false</code> and <code>null</code> types are treated as <code>String</code>, <code>boolean</code> and <code>null</code>, respectively. <code>Number</code> values treated as <code>long</code>s if they can be represented by a <code>long</code>.
				Otherwise, <code>number</code>s are treated as <code>double</code>s.</p>
				<p>It is possible to query nested attributes and arrays in JSON documents. The query syntax is the same as querying other Hazelcast objects using the <code>Predicate</code>s.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> departmentsMap;
<span class="hljs-keyword">var</span> departments = [
    {
        <span class="hljs-attr">departmentId</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">room</span>: <span class="hljs-string">'alpha'</span>,
        <span class="hljs-attr">people</span>: [
            {
                <span class="hljs-attr">name</span>: <span class="hljs-string">'Peter'</span>,
                <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,
                <span class="hljs-attr">salary</span>: <span class="hljs-number">50000</span>

            },
            {
                <span class="hljs-attr">name</span>: <span class="hljs-string">'Jonah'</span>,
                <span class="hljs-attr">age</span>: <span class="hljs-number">50</span>,
                <span class="hljs-attr">salary</span>: <span class="hljs-number">140000</span>
            }
        ]
    },
    {
        <span class="hljs-attr">departmentId</span>: <span class="hljs-number">2</span>,
        <span class="hljs-attr">room</span>: <span class="hljs-string">'beta'</span>,
        <span class="hljs-attr">people</span>: [
            {
                <span class="hljs-attr">name</span>: <span class="hljs-string">'Terry'</span>,
                <span class="hljs-attr">age</span>: <span class="hljs-number">44</span>,
                <span class="hljs-attr">salary</span>: <span class="hljs-number">100000</span>
            }
        ]
    }
];
<span class="hljs-keyword">return</span> hz.getMap(<span class="hljs-string">'departmentsMap'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">map</span>) </span>{
    departmentsMap = map;
    <span class="hljs-keyword">return</span> departmentsMap.putAll(departments.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">department, index</span>) </span>{
        <span class="hljs-keyword">return</span> [index, department];
    }));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// The following query finds all the departments that have a person named "Peter" working in them.</span>
    <span class="hljs-keyword">return</span> departmentsMap.valuesWithPredicate(Predicates.equal(<span class="hljs-string">'people[any].name'</span>, <span class="hljs-string">'Peter'</span>))
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">departmentWithPeter</span>) </span>{
    departmentWithPeter.toArray().forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">department</span>) </span>{
        <span class="hljs-built_in">console</span>.log(department);
    });
});
</code></pre>
				<p><code>HazelcastJsonValue</code> is a lightweight wrapper around your JSON strings. It is used merely as a way to indicate that the contained string should be treated as a valid JSON value.
					Hazelcast does not check the validity of JSON strings put into to maps. Putting an invalid JSON string in a map is permissible.
				However, in that case whether such an entry is going to be returned or not from a query is not defined.</p>
				<h5 id="querying-with-hazelcastjsonvalue-objects">Querying with HazelcastJsonValue Objects</h5>
				<p>If the Hazelcast Node.js client cannot find a suitable serializer for an object, it uses <code>JSON Serialization</code>.  </p>
				<p>This means that, you can run queries over your JavaScript objects if they are serialized as JSON strings. However, when the results
				of your query are ready, they are parsed from JSON strings and returned to you as JavaScript objects.</p>
				<p>For the purposes of your application, you may want to get rid of the parsing and just work with the raw JSON strings using <code>HazelcastJsonValue</code> objects. Then, you can configure your client to do so
				as described in the <a href="#45-json-serialization">JSON Serialization</a> section.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-keyword">new</span> Config();
config.serializationConfig.jsonStringDeserializationPolicy = JsonStringDeserializationPolicy.NO_DESERIALIZATION;

Client.newHazelcastClient(config).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hz</span>) </span>{
    <span class="hljs-keyword">var</span> moviesMap;
    <span class="hljs-keyword">var</span> movies = [
        [<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> HazelcastJsonValue(<span class="hljs-string">'{ "name": "The Dark Knight", "rating": 9.1 }'</span>)],
        [<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> HazelcastJsonValue(<span class="hljs-string">'{ "name": "Inception", "rating": 8.8 }'</span>)],
        [<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> HazelcastJsonValue(<span class="hljs-string">'{ "name": "The Prestige", "rating": 8.5 }'</span>)]
    ];
    <span class="hljs-keyword">return</span> hz.getMap(<span class="hljs-string">'moviesMap'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">map</span>) </span>{
        moviesMap = map;
        <span class="hljs-keyword">return</span> moviesMap.putAll(movies);
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> moviesMap.valuesWithPredicate(Predicates.greaterEqual(<span class="hljs-string">'rating'</span>, <span class="hljs-number">8.8</span>));
    }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">highRatedMovies</span>) </span>{
        highRatedMovies.toArray().forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">movie</span>) </span>{
            <span class="hljs-built_in">console</span>.log(movie.toString());
        });
        <span class="hljs-keyword">return</span> hz.shutdown();
    });
});
</code></pre>
				<h5 id="metadata-creation-for-json-querying">Metadata Creation for JSON Querying</h5>
				<p>Hazelcast stores a metadata object per JSON serialized object stored. This metadata object is created every time a JSON serialized object is put into an <code>IMap</code>.
				Metadata is later used to speed up the query operations. Metadata creation is on by default. Depending on your application’s needs, you may want to turn off the metadata creation to decrease the put latency and increase the throughput. </p>
				<p>You can configure this using <code>metadata-policy</code> element for the map configuration on the member side as follows:</p>
				<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hazelcast</span>&gt;</span>
    ...
    <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"map-a"</span>&gt;</span>
        <span class="hljs-comment">&lt;!--
        valid values for metadata-policy are:
          - OFF
          - CREATE_ON_UPDATE (default)
        --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">metadata-policy</span>&gt;</span>OFF<span class="hljs-tag">&lt;/<span class="hljs-name">metadata-policy</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">hazelcast</span>&gt;</span>
</code></pre>
				<h4 id="7-7-1-5-filtering-with-paging-predicates">7.7.1.5. Filtering with Paging Predicates</h4>
				<p>The Node.js client provides paging for defined predicates. With its <code>PagingPredicate</code> object, you can get a list of keys, values or entries page by page by filtering them with predicates and giving the size of the pages. Also, you can sort the entries by specifying comparators.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map;
hazelcastClient.getMap(<span class="hljs-string">'students'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    map = mp;

    <span class="hljs-keyword">var</span> greaterEqual = Predicates.greaterEqual(<span class="hljs-string">'age'</span>, <span class="hljs-number">18</span>);
    <span class="hljs-keyword">var</span> pagingPredicate = Predicates.paging(greaterEqual, <span class="hljs-number">5</span>);

<span class="hljs-comment">// Set page to retrieve third page</span>
    pagingPredicate.setPage(<span class="hljs-number">3</span>);

    <span class="hljs-comment">// Retrieve third page</span>
    <span class="hljs-keyword">return</span> map.valuesWithPredicate(pagingPredicate)
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>{
    <span class="hljs-comment">// some operations</span>
...

    <span class="hljs-comment">// Set up next page</span>
    pagingPredicate.nextPage();

    <span class="hljs-comment">// Retrieve next page</span>
    <span class="hljs-keyword">return</span> map.valuesWithPredicate(pagingPredicate);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>{
    <span class="hljs-comment">// some operations</span>
});
</code></pre>
				<p>If you want to sort the result before paging, you need to specify a comparator object that implements the <code>Comparator</code> interface. Also, this comparator object should be one of <code>IdentifiedDataSerializable</code> or <code>Portable</code>. After implementing this object in Node.js, you need to implement the Java equivalent of it and its factory. The Java equivalent of the comparator should implement <code>java.util.Comparator</code>. Note that the <code>compare</code> function of <code>Comparator</code> on the Java side is the equivalent of the <code>sort</code> function of <code>Comparator</code> on the Node.js side. When you implement the <code>Comparator</code> and its factory, you can add them to the <code>CLASSPATH</code> of the server side.  See the <a href="#1212-adding-user-library-to-classpath">Adding User Library to CLASSPATH section</a>.</p>
				<p>Also, you can access a specific page more easily with the help of the <code>setPage</code> function. This way, if you make a query for the 100th page, for example, it will get all 100 pages at once instead of reaching the 100th page one by one using the <code>nextPage</code> function.</p>
				<h3 id="7-7-2-fast-aggregations">7.7.2. Fast-Aggregations</h3>
				<p>Fast-Aggregations feature provides some aggregate functions, such as <code>sum</code>, <code>average</code>, <code>max</code>, and <code>min</code>, on top of Hazelcast <code>IMap</code> entries. Their performance is perfect since they run in parallel for each partition and are highly optimized for speed and low memory consumption.</p>
				<p>The <code>Aggregators</code> object provides a wide variety of built-in aggregators. The full list is presented below:</p>
				<ul>
					<li><code>count</code></li>
					<li><code>doubleAvg</code></li>
					<li><code>doubleSum</code></li>
					<li><code>numberAvg</code></li>
					<li><code>fixedPointSum</code></li>
					<li><code>floatingPointSum</code></li>
					<li><code>max</code></li>
					<li><code>min</code></li>
					<li><code>integerAvg</code></li>
					<li><code>integerSum</code></li>
					<li><code>longAvg</code></li>
					<li><code>longSum</code></li>
				</ul>
				<p>You can use these aggregators with the <code>IMap.aggregate()</code> and <code>IMap.aggregateWithPredicate()</code> functions.</p>
				<p>See the following example.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map;
hz.getMap(<span class="hljs-string">'employees'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    map = mp;
    <span class="hljs-keyword">return</span> map.putAll([
        [<span class="hljs-string">'John Stiles'</span>, <span class="hljs-number">23</span>],
        [<span class="hljs-string">'Judy Doe'</span>, <span class="hljs-number">29</span>],
        [<span class="hljs-string">'Richard Miles'</span>, <span class="hljs-number">38</span>],
    ]);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> map.aggregate(Aggregators.count());
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">count</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'There are '</span> + count + <span class="hljs-string">' employees.'</span>); <span class="hljs-comment">// There are 3 employees.</span>
    <span class="hljs-keyword">return</span> map.aggregateWithPredicate(Aggregators.count(), Predicates.greaterThan(<span class="hljs-string">'this'</span>, <span class="hljs-number">25</span>));
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">count</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'There are '</span> + count + <span class="hljs-string">' employees older than 25.'</span>); <span class="hljs-comment">// There are 2 employees older than 25.</span>
    <span class="hljs-keyword">return</span> map.aggregate(Aggregators.numberAvg());
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">avgAge</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Average age is '</span> + avgAge); <span class="hljs-comment">// Average age is 30</span>
});
</code></pre>
				<h2 id="7-8-performance">7.8. Performance</h2>
				<h3 id="7-8-1-partition-aware">7.8.1. Partition Aware</h3>
				<p>Partition Aware ensures that the related entries exist on the same member. If the related data is on the same member, operations can be executed without the cost of extra network calls and extra wire data, and this improves the performance. This feature is provided by using the same partition keys for related data.</p>
				<p>Hazelcast has a standard way of finding out which member owns/manages each key object. The following operations are routed to the same member, since all of them are operating based on the same key <code>&#39;key1&#39;</code>.</p>
				<pre><code class="lang-javascript">Client.newHazelcastClient().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>{
    hazelcastClient = client;
    <span class="hljs-keyword">return</span> hazelcastClient.getMap(<span class="hljs-string">'mapA'</span>)
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    mapA = mp;
    <span class="hljs-keyword">return</span> hazelcastClient.getMap(<span class="hljs-string">'mapB'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    mapB = mp;
    <span class="hljs-keyword">return</span> hazelcastClient.getMap(<span class="hljs-string">'mapC'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    mapC = mp;

    <span class="hljs-comment">// since map names are different, operation is manipulating</span>
    <span class="hljs-comment">// different entries, but the operation takes place on the</span>
    <span class="hljs-comment">// same member since the keys ('key1') are the same</span>
    <span class="hljs-keyword">return</span> mapA.put(<span class="hljs-string">'key1'</span>, <span class="hljs-string">'value1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> mapB.get(<span class="hljs-string">'key1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
    <span class="hljs-keyword">return</span> mapC.remove(<span class="hljs-string">'key1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// lock operation is still execute on the same member</span>
    <span class="hljs-comment">// of the cluster since the key ("key1") is same</span>
    <span class="hljs-keyword">return</span> hazelcastClient.getLock(<span class="hljs-string">'key1'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">l</span>) </span>{
    lock = l;
    <span class="hljs-keyword">return</span> lock.lock();
});
</code></pre>
				<p>When the keys are the same, entries are stored on the same member. However, we sometimes want to have the related entries stored on the same member, such as a customer and his/her order entries. We would have a customers map with <code>customerId</code> as the key and an orders map with <code>orderId</code> as the key. Since <code>customerId</code> and <code>orderId</code> are different keys, a customer and his/her orders may fall into different members in your cluster. So how can we have them stored on the same member? We create an affinity between the customer and orders. If we make them part of the same partition then these entries will be co-located. We achieve this by making <code>OrderKey</code>s <code>PartitionAware</code>.</p>
				<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OrderKey</span>(<span class="hljs-params">orderId, customerId</span>) </span>{
    <span class="hljs-keyword">this</span>.orderId = orderId;
    <span class="hljs-keyword">this</span>.customerId = customerId;
}

OrderKey.prototype.getPartitionKey = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.customerId;
};
</code></pre>
				<p>Notice that <code>OrderKey</code> implements <code>PartitionAware</code> interface and that <code>getPartitionKey()</code> returns the <code>customerId</code>. This will make sure that the <code>Customer</code> entry and its <code>Order</code>s will be stored on the same member.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> hazelcastClient;
<span class="hljs-keyword">var</span> mapCustomers;
<span class="hljs-keyword">var</span> mapOrders;

Client.newHazelcastClient().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>{
    hazelcastClient = client;
    <span class="hljs-keyword">return</span> hazelcastClient.getMap(<span class="hljs-string">'customers'</span>)
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    mapCustomers = mp;
    <span class="hljs-keyword">return</span> hazelcastClient.getMap(<span class="hljs-string">'orders'</span>);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mp</span>) </span>{
    mapOrders = mp;

    <span class="hljs-comment">// create the customer entry with customer id = 1</span>
    <span class="hljs-keyword">return</span> mapCustomers.put(<span class="hljs-number">1</span>, customer);
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">// now create the orders for this customer</span>
    <span class="hljs-keyword">return</span> mapOrders.putAll([
        [<span class="hljs-keyword">new</span> OrderKey(<span class="hljs-number">21</span>, <span class="hljs-number">1</span>), order],
        [<span class="hljs-keyword">new</span> OrderKey(<span class="hljs-number">22</span>, <span class="hljs-number">1</span>), order],
        [<span class="hljs-keyword">new</span> OrderKey(<span class="hljs-number">23</span>, <span class="hljs-number">1</span>), order]
    ]);
});
</code></pre>
				<p>For more details, see the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/#partitionaware">PartitionAware section</a> in the Hazelcast IMDG Reference Manual.</p>
				<h3 id="7-8-2-near-cache">7.8.2. Near Cache</h3>
				<p>Map entries in Hazelcast are partitioned across the cluster members. Hazelcast clients do not have local data at all. Suppose you read the key <code>k</code> a number of times from a Hazelcast client and <code>k</code> is owned by a member in your cluster. Then each <code>map.get(k)</code> will be a remote operation, which creates a lot of network trips. If you have a map that is mostly read, then you should consider creating a local Near Cache, so that reads are sped up and less network traffic is created.</p>
				<p>These benefits do not come for free, please consider the following trade-offs:</p>
				<ul>
					<li><p>If invalidation is enabled and entries are updated frequently, then invalidations will be costly.</p>
					</li>
					<li><p>Near Cache breaks the strong consistency guarantees; you might be reading stale data.</p>
					</li>
					<li><p>Clients with a Near Cache will have to hold the extra cached data, which increases memory consumption.</p>
					</li>
				</ul>
				<p>Near Cache is highly recommended for maps that are mostly read.</p>
				<h4 id="7-8-2-1-configuring-near-cache">7.8.2.1. Configuring Near Cache</h4>
				<p>The following snippets show how a Near Cache is configured in the Node.js client, presenting all available values for each element:</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code>{
    <span class="hljs-attr">"nearCaches"</span>: [
        {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"mostlyReadMap"</span>,
            <span class="hljs-attr">"invalidateOnChange"</span>: (<span class="hljs-literal">false</span>|<span class="hljs-literal">true</span>),
            <span class="hljs-attr">"timeToLiveSeconds"</span>: (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER),
            <span class="hljs-attr">"maxIdleSeconds"</span>: (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER),
            <span class="hljs-attr">"inMemoryFormat"</span>: <span class="hljs-string">"(object|binary)"</span>,
            <span class="hljs-attr">"evictionPolicy"</span>: <span class="hljs-string">"lru|lfu|random|none"</span>,
            <span class="hljs-attr">"evictionMaxSize"</span>: (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER),
            <span class="hljs-attr">"evictionSamplingCount"</span>: (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER),
            <span class="hljs-attr">"evictionSamplingPoolSize"</span>: (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER),
        }
    ]
}
</code></pre><p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> nearCacheConfig = <span class="hljs-keyword">new</span> Config.NearCacheConfig();
nearCacheConfig.name = <span class="hljs-string">'mostlyReadMap'</span>;
nearCacheConfig.invalidateOnChange = (<span class="hljs-literal">false</span>|<span class="hljs-literal">true</span>);
nearCacheConfig.timeToLiveSeconds = (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER);
nearCacheConfig.maxIdleSeconds = (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER);
nearCacheConfig.inMemoryFormat= (InMemoryFormat.OBJECT|InMemoryFormat.BINARY);
nearCacheConfig.evictionPolicy = (EvictionPolicy.LRU|EvictionPolicy.LFU|EvictionPolicy.RANDOM|EvictionPolicy.NONE);
nearCacheConfig.evictionMaxSize = (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER);
nearCacheConfig.evictionSamplingCount = (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER);
nearCacheConfig.evictionSamplingPoolSize = (<span class="hljs-number">0.</span>.Number.MAX_SAFE_INTEGER);

cfg.nearCacheConfigs[<span class="hljs-string">'mostlyReadMap'</span>] = nearCacheConfig;
</code></pre>
				<p>Following are the descriptions of all configuration elements:</p>
				<ul>
					<li><p><code>inMemoryFormat</code>: Specifies in which format data will be stored in your Near Cache. Note that a map’s in-memory format can be different from that of its Near Cache. Available values are as follows:</p>
						<ul>
							<li><code>BINARY</code>: Data will be stored in serialized binary format (default value).</li>
							<li><code>OBJECT</code>: Data will be stored in deserialized form.</li>
						</ul>
					</li>
					<li><p><code>invalidateOnChange</code>: Specifies whether the cached entries are evicted when the entries are updated or removed in members. Its default value is true.</p>
					</li>
					<li><p><code>timeToLiveSeconds</code>: Maximum number of seconds for each entry to stay in the Near Cache. Entries that are older than this period are automatically evicted from the Near Cache. Regardless of the eviction policy used, <code>timeToLiveSeconds</code> still applies. Any integer between 0 and <code>Number.MAX_SAFE_INTEGER</code>. 0 means infinite. Its default value is 0.</p>
					</li>
					<li><p><code>maxIdleSeconds</code>: Maximum number of seconds each entry can stay in the Near Cache as untouched (not read). Entries that are not read more than this period are removed from the Near Cache. Any integer between 0 and <code>Number.MAX_SAFE_INTEGER</code>. 0 means infinite. Its default value is 0.</p>
					</li>
					<li><p><code>evictionPolicy</code>: Eviction policy configuration. Available values are as follows:</p>
						<ul>
							<li><code>LRU</code>: Least Recently Used (default value).</li>
							<li><code>LFU</code>: Least Frequently Used.</li>
							<li><code>NONE</code>: No items are evicted and the <code>evictionMaxSize</code> property is ignored. You still can combine it with <code>timeToLiveSeconds</code> and <code>maxIdleSeconds</code> to evict items from the Near Cache.</li>
							<li><code>RANDOM</code>: A random item is evicted.</li>
						</ul>
					</li>
					<li><p><code>evictionMaxSize</code>: Maximum number of entries kept in the memory before eviction kicks in.</p>
					</li>
					<li><code>evictionSamplingCount</code>: Number of random entries that are evaluated to see if some of them are already expired. If there are expired entries, those are removed and there is no need for eviction.</li>
					<li><code>evictionSamplingPoolSize</code>: Size of the pool for eviction candidates. The pool is kept sorted according to eviction policy. The entry with the highest score is evicted.</li>
				</ul>
				<h4 id="7-8-2-2-near-cache-example-for-map">7.8.2.2. Near Cache Example for Map</h4>
				<p>The following is an example configuration for a Near Cache defined in the <code>mostlyReadMap</code> map. According to this configuration, the entries are stored as <code>OBJECT</code>&#39;s in this Near Cache and eviction starts when the count of entries reaches <code>5000</code>; entries are evicted based on the <code>LRU</code> (Least Recently Used) policy. In addition, when an entry is updated or removed on the member side, it is eventually evicted on the client side.</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code>{
    <span class="hljs-attr">"nearCaches"</span>: [
        {
            <span class="hljs-attr">"name"</span>: <span class="hljs-string">"mostlyReadMap"</span>,
            <span class="hljs-attr">"inMemoryFormat"</span>: <span class="hljs-string">"object"</span>,
            <span class="hljs-attr">"invalidateOnChange"</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">"evictionPolicy"</span>: <span class="hljs-string">"lru"</span>,
            <span class="hljs-attr">"evictionMaxSize"</span>: <span class="hljs-number">5000</span>,
        }
    ]
}
</code></pre><p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> nearCacheConfig = <span class="hljs-keyword">new</span> Config.NearCacheConfig();
nearCacheConfig.name = <span class="hljs-string">"mostlyReadMap"</span>;
nearCacheConfig.inMemoryFormat= InMemoryFormat.OBJECT;
nearCacheConfig.invalidateOnChange = <span class="hljs-literal">true</span>;
nearCacheConfig.evictionPolicy = EvictionPolicy.LRU;
nearCacheConfig.evictionMaxSize = <span class="hljs-number">5000</span>;

cfg.nearCacheConfigs[<span class="hljs-string">'mostlyReadMap'</span>] = nearCacheConfig;
</code></pre>
				<h4 id="7-8-2-3-near-cache-eviction">7.8.2.3. Near Cache Eviction</h4>
				<p>In the scope of Near Cache, eviction means evicting (clearing) the entries selected according to the given <code>evictionPolicy</code> when the specified <code>evictionMaxSize</code> has been reached.</p>
				<p>The <code>evictionMaxSize</code> defines the entry count when the Near Cache is full and determines whether the eviction should be triggered.</p>
				<p>Once the eviction is triggered the configured <code>evictionPolicy</code> determines which, if any, entries must be evicted.</p>
				<h4 id="7-8-2-4-near-cache-expiration">7.8.2.4. Near Cache Expiration</h4>
				<p>Expiration means the eviction of expired records. A record is expired:</p>
				<ul>
					<li><p>if it is not touched (accessed/read) for <code>maxIdleSeconds</code></p>
					</li>
					<li><p><code>timeToLiveSeconds</code> passed since it is put to Near Cache</p>
					</li>
				</ul>
				<p>The actual expiration is performed when a record is accessed: it is checked if the record is expired or not. If it is expired, it is evicted and <code>undefined</code> is returned as the value to the caller.</p>
				<h4 id="7-8-2-5-near-cache-invalidation">7.8.2.5. Near Cache Invalidation</h4>
				<p>Invalidation is the process of removing an entry from the Near Cache when its value is updated or it is removed from the original map (to prevent stale reads). See the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/#near-cache-invalidation">Near Cache Invalidation section</a> in the Hazelcast IMDG Reference Manual.</p>
				<h4 id="7-8-2-6-near-cache-eventual-consistency">7.8.2.6. Near Cache Eventual Consistency</h4>
				<p>Near Caches are invalidated by invalidation events. Invalidation events can be lost due to the fire-and-forget fashion of eventing system. If an event is lost, reads from Near Cache can indefinitely be stale.</p>
				<p>To solve this problem, Hazelcast provides eventually consistent behavior for Map Near Caches by detecting invalidation losses. After detection of an invalidation loss, stale data will be made unreachable and Near Cache’s <code>get</code> calls to that data will be directed to underlying Map to fetch the fresh data.</p>
				<p>You can configure eventual consistency with the <code>ClientConfig.properties</code> below:</p>
				<ul>
					<li><p><code>hazelcast.invalidation.max.tolerated.miss.count</code>: Default value is <code>10</code>. If missed invalidation count is bigger than this value, relevant cached data will be made unreachable.</p>
					</li>
					<li><p><code>hazelcast.invalidation.reconciliation.interval.seconds</code>: Default value is <code>60</code> seconds. This is a periodic task that scans cluster members periodically to compare generated invalidation events with the received ones from the client Near Cache.</p>
					</li>
				</ul>
				<h2 id="7-9-monitoring-and-logging">7.9. Monitoring and Logging</h2>
				<h3 id="7-9-1-enabling-client-statistics">7.9.1. Enabling Client Statistics</h3>
				<p>You can monitor your clients using Hazelcast Management Center.</p>
				<p>As a prerequisite, you need to enable the client statistics before starting your clients. This can be done by setting the <code>hazelcast.client.statistics.enabled</code> system property to <code>true</code> on the <strong>member</strong> as the following:</p>
				<pre><code class="lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">hazelcast</span>&gt;</span>
    ...
    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hazelcast.client.statistics.enabled"</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">hazelcast</span>&gt;</span>
</code></pre>
				<p>Also, you need to enable the client statistics in the Node.js client. There are two properties related to client statistics:</p>
				<ul>
					<li><p><code>hazelcast.client.statistics.enabled</code>: If set to <code>true</code>, it enables collecting the client statistics and sending them to the cluster. When it is <code>true</code> you can monitor the clients that are connected to your Hazelcast cluster, using Hazelcast Management Center. Its default value is <code>false</code>.</p>
					</li>
					<li><p><code>hazelcast.client.statistics.period.seconds</code>: Period in seconds the client statistics are collected and sent to the cluster. Its default value is <code>3</code>.</p>
					</li>
				</ul>
				<p>You can enable client statistics and set a non-default period in seconds as follows:</p>
				<p><strong>Declarative Configuration:</strong></p>
				<pre><code class="lang-json">{
    <span class="hljs-attr">"properties"</span>: {
        <span class="hljs-attr">"hazelcast.client.statistics.enabled"</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">"hazelcast.client.statistics.period.seconds"</span>: <span class="hljs-number">4</span>,
    }
}
</code></pre>
				<p><strong>Programmatic Configuration:</strong></p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> config = <span class="hljs-keyword">new</span> Config.ClientConfig();
config.properties[<span class="hljs-string">'hazelcast.client.statistics.enabled'</span>] = <span class="hljs-literal">true</span>;
config.properties[<span class="hljs-string">'hazelcast.client.statistics.period.seconds'</span>] = <span class="hljs-number">4</span>;
</code></pre>
				<p>After enabling the client statistics, you can monitor your clients using Hazelcast Management Center. Please refer to the <a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-clients">Monitoring Clients section</a> in the Hazelcast Management Center Reference Manual for more information on the client statistics.</p>
				<h3 id="7-9-2-logging-configuration">7.9.2. Logging Configuration</h3>
				<p> To configure a logger, you need to use the <code>ClientConfig.properties[&#39;hazelcast.logging&#39;]</code> property. If you set it to <code>&#39;off&#39;</code>, it does not log anything.</p>
				<p>By default, there is a <code>Default Logger</code>. Also, it is possible to connect a custom logging library to Hazelcast Node.js client through adapters.</p>
				<p>See the following <code>winston</code> logging library example.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> winstonAdapter = {
    <span class="hljs-attr">logger</span>: <span class="hljs-keyword">new</span> (winston.Logger)({
        <span class="hljs-attr">transports</span>: [
            <span class="hljs-keyword">new</span> (winston.transports.Console)()
        ]
    }),

    <span class="hljs-attr">levels</span>: [
        <span class="hljs-string">'error'</span>,
        <span class="hljs-string">'warn'</span>,
        <span class="hljs-string">'info'</span>,
        <span class="hljs-string">'debug'</span>,
        <span class="hljs-string">'silly'</span>
    ],

    <span class="hljs-attr">log</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">level, className, message, furtherInfo</span>) </span>{
        <span class="hljs-keyword">this</span>.logger.log(<span class="hljs-keyword">this</span>.levels[level], className + <span class="hljs-string">' '</span> + message);
    }
};
config.properties[<span class="hljs-string">'hazelcast.logging'</span>] = winstonAdapter;
</code></pre>
				<p>Note that it is not possible to configure custom logging via declarative configuration.</p>
				<h1 id="8-development-and-testing">8. Development and Testing</h1>
				<p>Hazelcast Node.js client is developed using TypeScript. If you want to help with bug fixes, develop new features or
				tweak the implementation to your application&#39;s needs, you can follow the steps in this section.</p>
				<h2 id="8-1-building-and-using-client-from-sources">8.1. Building and Using Client From Sources</h2>
				<p>Follow the below steps to build and install Hazelcast Node.js client from its source:</p>
				<ol>
					<li>Clone the GitHub repository (<a href="https://github.com/hazelcast/hazelcast-nodejs-client.git">https://github.com/hazelcast/hazelcast-nodejs-client.git</a>).</li>
					<li>Run <code>npm install</code> to automatically download and install all the required modules under <code>node_modules</code> directory. Note that,
					there may be vulnerabilities reported due to <code>devDependencies</code>. In that case, run <code>npm audit fix</code> to automatically install any compatible updates to vulnerable dependencies.</li>
					<li>Run <code>npm run compile</code> to compile TypeScript files to JavaScript.</li>
				</ol>
				<p>At this point you have all the runnable code (<code>.js</code>) and type declarations (<code>.d.ts</code>) in the <code>lib</code> directory. You may create a link to this module so that your local
				applications can depend on your local copy of Hazelcast Node.js client. In order to create a link, run the below command:</p>
				<pre><code><span class="hljs-built_in">npm</span> link
</code></pre><p>This will create a global link to this module in your computer. Whenever you need to depend on this module from another
				local project, run the below command:</p>
				<pre><code>npm link hazelcast-<span class="hljs-keyword">client</span>
</code></pre><p>If you are planning to contribute, please run the style checker, as shown below, and fix the reported issues before sending a pull request:</p>
				<pre><code>npm <span class="hljs-keyword">run</span><span class="bash"> lint</span>
</code></pre><h2 id="8-2-testing">8.2. Testing</h2>
				<p>In order to test Hazelcast Node.js client locally, you will need the following:</p>
				<ul>
					<li>Java 6 or newer</li>
					<li>Maven</li>
				</ul>
				<p>Following command starts the tests:</p>
				<pre><code>npm <span class="hljs-built_in">test</span>
</code></pre><p>Test script automatically downloads <code>hazelcast-remote-controller</code> and Hazelcast IMDG. The script uses Maven to download those.</p>
				<h1 id="9-getting-help">9. Getting Help</h1>
				<p>You can use the following channels for your questions and development/usage issues:</p>
				<ul>
					<li>This repository by opening an issue.</li>
					<li>Hazelcast Node.js client channel on Gitter:
					<a href="https://gitter.im/hazelcast-incubator/hazelcast-nodejs-client?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/hazelcast-incubator/hazelcast-nodejs-client"></a></li>
					<li>Our Google Groups directory: <a href="https://groups.google.com/forum/#!forum/hazelcast">https://groups.google.com/forum/#!forum/hazelcast</a></li>
					<li>Stack Overflow: <a href="https://stackoverflow.com/questions/tagged/hazelcast">https://stackoverflow.com/questions/tagged/hazelcast</a></li>
				</ul>
				<h1 id="10-contributing">10. Contributing</h1>
				<p>Besides your development contributions as explained in the <a href="#8-development-and-testing">Development and Testing chapter</a> above, you can always open a pull request on this repository for your other requests such as documentation changes.</p>
				<h1 id="11-license">11. License</h1>
				<p><a href="https://github.com/hazelcast/hazelcast-nodejs-client/blob/master/LICENSE">Apache 2 License</a>.</p>
				<h1 id="12-copyright">12. Copyright</h1>
				<p>Copyright (c) 2008-2018, Hazelcast, Inc. All Rights Reserved.</p>
				<p>Visit <a href="http://www.hazelcast.com">www.hazelcast.com</a> for more information.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_address_.html">"<wbr>Address"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_bitsutil_.html">"<wbr>Bits<wbr>Util"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_buildinfo_.html">"<wbr>Build<wbr>Info"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_clientinfo_.html">"<wbr>Client<wbr>Info"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_clientmessage_.html">"<wbr>Client<wbr>Message"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_clusterdatafactory_.html">"<wbr>Cluster<wbr>Data<wbr>Factory"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_clusterdatafactoryhelper_.html">"<wbr>Cluster<wbr>Data<wbr>Factory<wbr>Helper"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_datastorehashmap_.html">"<wbr>Data<wbr>Store<wbr>Hash<wbr>Map"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_distributedobject_.html">"<wbr>Distributed<wbr>Object"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_hazelcastclient_.html">"<wbr>Hazelcast<wbr>Client"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_hazelcasterror_.html">"<wbr>Hazelcast<wbr>Error"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_heartbeatservice_.html">"<wbr>Heartbeat<wbr>Service"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lifecycleservice_.html">"<wbr>Lifecycle<wbr>Service"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_listenermessagecodec_.html">"<wbr>Listener<wbr>Message<wbr>Codec"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_listenerservice_.html">"<wbr>Listener<wbr>Service"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_lockreferenceidgenerator_.html">"<wbr>Lock<wbr>Reference<wbr>IdGenerator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_partitionservice_.html">"<wbr>Partition<wbr>Service"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util_.html">"<wbr>Util"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_aggregation_aggregator_.html">"aggregation/<wbr>Aggregator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_aggregation_aggregatorfactory_.html">"aggregation/<wbr>Aggregator<wbr>Factory"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_aggregation_aggregators_.html">"aggregation/<wbr>Aggregators"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_clientcloudconfig_.html">"config/<wbr>Client<wbr>Cloud<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_clientnetworkconfig_.html">"config/<wbr>Client<wbr>Network<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_config_.html">"config/<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_configbuilder_.html">"config/<wbr>Config<wbr>Builder"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_configpatternmatcher_.html">"config/<wbr>Config<wbr>Pattern<wbr>Matcher"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_evictionpolicy_.html">"config/<wbr>Eviction<wbr>Policy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_flakeidgeneratorconfig_.html">"config/<wbr>Flake<wbr>IdGenerator<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_groupconfig_.html">"config/<wbr>Group<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_importconfig_.html">"config/<wbr>Import<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_inmemoryformat_.html">"config/<wbr>InMemory<wbr>Format"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_jsonconfiglocator_.html">"config/<wbr>Json<wbr>Config<wbr>Locator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_jsonstringdeserializationpolicy_.html">"config/<wbr>Json<wbr>String<wbr>Deserialization<wbr>Policy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_listenerconfig_.html">"config/<wbr>Listener<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_nearcacheconfig_.html">"config/<wbr>Near<wbr>Cache<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_properties_.html">"config/<wbr>Properties"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_reliabletopicconfig_.html">"config/<wbr>Reliable<wbr>Topic<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_sslconfig_.html">"config/SSLConfig"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_serializationconfig_.html">"config/<wbr>Serialization<wbr>Config"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_config_stringserializationpolicy_.html">"config/<wbr>String<wbr>Serialization<wbr>Policy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_connection_addressprovider_.html">"connection/<wbr>Address<wbr>Provider"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_connection_addresstranslator_.html">"connection/<wbr>Address<wbr>Translator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_connection_basicssloptionsfactory_.html">"connection/<wbr>BasicSSLOptions<wbr>Factory"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_connection_defaultaddressprovider_.html">"connection/<wbr>Default<wbr>Address<wbr>Provider"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_connection_defaultaddresstranslator_.html">"connection/<wbr>Default<wbr>Address<wbr>Translator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_connection_ssloptionsfactory_.html">"connection/SSLOptions<wbr>Factory"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_comparator_.html">"core/<wbr>Comparator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_connectionheartbeatlistener_.html">"core/<wbr>Connection<wbr>Heartbeat<wbr>Listener"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_distributedobjectlistener_.html">"core/<wbr>Distributed<wbr>Object<wbr>Listener"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_entrylistener_.html">"core/<wbr>Entry<wbr>Listener"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_entryview_.html">"core/<wbr>Entry<wbr>View"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_eventtype_.html">"core/<wbr>Event<wbr>Type"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_hazelcastjsonvalue_.html">"core/<wbr>Hazelcast<wbr>Json<wbr>Value"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_itemlistener_.html">"core/<wbr>Item<wbr>Listener"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_maplistener_.html">"core/<wbr>Map<wbr>Listener"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_member_.html">"core/<wbr>Member"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_memberattributeevent_.html">"core/<wbr>Member<wbr>Attribute<wbr>Event"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_memberselector_.html">"core/<wbr>Member<wbr>Selector"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_memberselectors_.html">"core/<wbr>Member<wbr>Selectors"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_membershipevent_.html">"core/<wbr>Membership<wbr>Event"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_membershiplistener_.html">"core/<wbr>Membership<wbr>Listener"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_overflowpolicy_.html">"core/<wbr>Overflow<wbr>Policy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_partitionaware_.html">"core/<wbr>Partition<wbr>Aware"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_predicate_.html">"core/<wbr>Predicate"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_readonlylazylist_.html">"core/<wbr>Read<wbr>Only<wbr>Lazy<wbr>List"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_uuid_.html">"core/UUID"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_core_vectorclock_.html">"core/<wbr>Vector<wbr>Clock"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_discovery_hazelcastcloudaddressprovider_.html">"discovery/<wbr>Hazelcast<wbr>Cloud<wbr>Address<wbr>Provider"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_discovery_hazelcastcloudaddresstranslator_.html">"discovery/<wbr>Hazelcast<wbr>Cloud<wbr>Address<wbr>Translator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_discovery_hazelcastclouddiscovery_.html">"discovery/<wbr>Hazelcast<wbr>Cloud<wbr>Discovery"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_index_.html">"index"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_invocation_clientconnection_.html">"invocation/<wbr>Client<wbr>Connection"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_invocation_clientconnectionmanager_.html">"invocation/<wbr>Client<wbr>Connection<wbr>Manager"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_invocation_clienteventregistration_.html">"invocation/<wbr>Client<wbr>Event<wbr>Registration"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_invocation_clusterservice_.html">"invocation/<wbr>Cluster<wbr>Service"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_invocation_connectionauthenticator_.html">"invocation/<wbr>Connection<wbr>Authenticator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_invocation_invocationservice_.html">"invocation/<wbr>Invocation<wbr>Service"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_invocation_murmur_.html">"invocation/<wbr>Murmur"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_invocation_registrationkey_.html">"invocation/<wbr>Registration<wbr>Key"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_logging_defaultlogger_.html">"logging/<wbr>Default<wbr>Logger"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_logging_ilogger_.html">"logging/ILogger"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_logging_loggingservice_.html">"logging/<wbr>Logging<wbr>Service"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_alwaysfreshstalereaddetectorimpl_.html">"nearcache/<wbr>Always<wbr>Fresh<wbr>Stale<wbr>Read<wbr>Detector<wbr>Impl"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_datarecord_.html">"nearcache/<wbr>Data<wbr>Record"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_metadatacontainer_.html">"nearcache/<wbr>Metadata<wbr>Container"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_metadatafetcher_.html">"nearcache/<wbr>Metadata<wbr>Fetcher"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_nearcache_.html">"nearcache/<wbr>Near<wbr>Cache"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_nearcachemanager_.html">"nearcache/<wbr>Near<wbr>Cache<wbr>Manager"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_repairinghandler_.html">"nearcache/<wbr>Repairing<wbr>Handler"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_repairingtask_.html">"nearcache/<wbr>Repairing<wbr>Task"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_stalereaddetector_.html">"nearcache/<wbr>Stale<wbr>Read<wbr>Detector"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_nearcache_stalereaddetectorimpl_.html">"nearcache/<wbr>Stale<wbr>Read<wbr>Detector<wbr>Impl"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_protocol_clientprotocolerrorcodes_.html">"protocol/<wbr>Client<wbr>Protocol<wbr>Error<wbr>Codes"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_protocol_errorcodec_.html">"protocol/<wbr>Error<wbr>Codec"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_protocol_errorfactory_.html">"protocol/<wbr>Error<wbr>Factory"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_protocol_stacktraceelementcodec_.html">"protocol/<wbr>Stack<wbr>Trace<wbr>Element<wbr>Codec"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_atomiclongproxy_.html">"proxy/<wbr>Atomic<wbr>Long<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_baseproxy_.html">"proxy/<wbr>Base<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_flakeidgenerator_.html">"proxy/<wbr>Flake<wbr>IdGenerator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_flakeidgeneratorproxy_.html">"proxy/<wbr>Flake<wbr>IdGenerator<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_iatomiclong_.html">"proxy/IAtomic<wbr>Long"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_ilist_.html">"proxy/IList"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_ilock_.html">"proxy/ILock"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_imap_.html">"proxy/IMap"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_iqueue_.html">"proxy/IQueue"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_isemaphore_.html">"proxy/ISemaphore"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_iset_.html">"proxy/ISet"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_listproxy_.html">"proxy/<wbr>List<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_lockproxy_.html">"proxy/<wbr>Lock<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_mapproxy_.html">"proxy/<wbr>Map<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_multimap_.html">"proxy/<wbr>Multi<wbr>Map"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_multimapproxy_.html">"proxy/<wbr>Multi<wbr>Map<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_nearcachedmapproxy_.html">"proxy/<wbr>Near<wbr>Cached<wbr>Map<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_pncounter_.html">"proxy/PNCounter"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_pncounterproxy_.html">"proxy/PNCounter<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_partitionspecificproxy_.html">"proxy/<wbr>Partition<wbr>Specific<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_proxymanager_.html">"proxy/<wbr>Proxy<wbr>Manager"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_queueproxy_.html">"proxy/<wbr>Queue<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_replicatedmap_.html">"proxy/<wbr>Replicated<wbr>Map"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_replicatedmapproxy_.html">"proxy/<wbr>Replicated<wbr>Map<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_ringbuffer_.html">"proxy/<wbr>Ringbuffer"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_semaphoreproxy_.html">"proxy/<wbr>Semaphore<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_setproxy_.html">"proxy/<wbr>Set<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_flakeid_autobatcher_.html">"proxy/flakeid/<wbr>Auto<wbr>Batcher"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_ringbuffer_lazyreadresultset_.html">"proxy/ringbuffer/<wbr>Lazy<wbr>Read<wbr>Result<wbr>Set"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_ringbuffer_readresultset_.html">"proxy/ringbuffer/<wbr>Read<wbr>Result<wbr>Set"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_ringbuffer_ringbufferproxy_.html">"proxy/ringbuffer/<wbr>Ringbuffer<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_topic_itopic_.html">"proxy/topic/ITopic"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_topic_message_.html">"proxy/topic/<wbr>Message"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_topic_messagelistener_.html">"proxy/topic/<wbr>Message<wbr>Listener"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_topic_reliabletopiclistenerrunner_.html">"proxy/topic/<wbr>Reliable<wbr>Topic<wbr>Listener<wbr>Runner"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_topic_reliabletopicmessage_.html">"proxy/topic/<wbr>Reliable<wbr>Topic<wbr>Message"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_topic_reliabletopicproxy_.html">"proxy/topic/<wbr>Reliable<wbr>Topic<wbr>Proxy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_proxy_topic_topicoverloadpolicy_.html">"proxy/topic/<wbr>Topic<wbr>Overload<wbr>Policy"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_data_.html">"serialization/<wbr>Data"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_defaultpredicates_.html">"serialization/<wbr>Default<wbr>Predicates"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_defaultserializer_.html">"serialization/<wbr>Default<wbr>Serializer"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_heapdata_.html">"serialization/<wbr>Heap<wbr>Data"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_objectdata_.html">"serialization/<wbr>Object<wbr>Data"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_predicatefactory_.html">"serialization/<wbr>Predicate<wbr>Factory"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_serializable_.html">"serialization/<wbr>Serializable"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_serializationservice_.html">"serialization/<wbr>Serialization<wbr>Service"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_serializationutil_.html">"serialization/<wbr>Serialization<wbr>Util"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_classdefinition_.html">"serialization/portable/<wbr>Class<wbr>Definition"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_classdefinitionbuilder_.html">"serialization/portable/<wbr>Class<wbr>Definition<wbr>Builder"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_classdefinitioncontext_.html">"serialization/portable/<wbr>Class<wbr>Definition<wbr>Context"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_classdefinitionwriter_.html">"serialization/portable/<wbr>Class<wbr>Definition<wbr>Writer"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_defaultportablereader_.html">"serialization/portable/<wbr>Default<wbr>Portable<wbr>Reader"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_defaultportablewriter_.html">"serialization/portable/<wbr>Default<wbr>Portable<wbr>Writer"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_morphingportablereader_.html">"serialization/portable/<wbr>Morphing<wbr>Portable<wbr>Reader"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_portablecontext_.html">"serialization/portable/<wbr>Portable<wbr>Context"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_serialization_portable_portableserializer_.html">"serialization/portable/<wbr>Portable<wbr>Serializer"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_statistics_statistics_.html">"statistics/<wbr>Statistics"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util_arraycomparator_.html">"util/<wbr>Array<wbr>Comparator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_util_uuidutil_.html">"util/<wbr>Uuid<wbr>Util"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>